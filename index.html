<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="The PartiQL Specification Committee">
<meta name="copyright" content="Copyright ©2019 Amazon.com Inc. or Affiliates (“Amazon”)">
<title>PartiQL Specification</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments { background: #ffffff; }
pre.pygments .tok-c { color: #888888 } /* Comment */
pre.pygments .tok-err { color: #FF0000; background-color: #FFAAAA } /* Error */
pre.pygments .tok-k { color: #008800; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #333333 } /* Operator */
pre.pygments .tok-ch { color: #888888 } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #888888 } /* Comment.Multiline */
pre.pygments .tok-cp { color: #557799 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #888888 } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #888888 } /* Comment.Single */
pre.pygments .tok-cs { color: #cc0000; font-weight: bold } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008800; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008800; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008800; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #003388; font-weight: bold } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008800; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #333399; font-weight: bold } /* Keyword.Type */
pre.pygments .tok-m { color: #6600EE; font-weight: bold } /* Literal.Number */
pre.pygments .tok-s { background-color: #fff0f0 } /* Literal.String */
pre.pygments .tok-na { color: #0000CC } /* Name.Attribute */
pre.pygments .tok-nb { color: #007020 } /* Name.Builtin */
pre.pygments .tok-nc { color: #BB0066; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #003366; font-weight: bold } /* Name.Constant */
pre.pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
pre.pygments .tok-ni { color: #880000; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #FF0000; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0066BB; font-weight: bold } /* Name.Function */
pre.pygments .tok-nl { color: #997700; font-weight: bold } /* Name.Label */
pre.pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #007700 } /* Name.Tag */
pre.pygments .tok-nv { color: #996633 } /* Name.Variable */
pre.pygments .tok-ow { color: #000000; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #6600EE; font-weight: bold } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #6600EE; font-weight: bold } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #005588; font-weight: bold } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #0000DD; font-weight: bold } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #4400EE; font-weight: bold } /* Literal.Number.Oct */
pre.pygments .tok-sa { background-color: #fff0f0 } /* Literal.String.Affix */
pre.pygments .tok-sb { background-color: #fff0f0 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #0044DD } /* Literal.String.Char */
pre.pygments .tok-dl { background-color: #fff0f0 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #DD4422 } /* Literal.String.Doc */
pre.pygments .tok-s2 { background-color: #fff0f0 } /* Literal.String.Double */
pre.pygments .tok-se { color: #666666; font-weight: bold; background-color: #fff0f0 } /* Literal.String.Escape */
pre.pygments .tok-sh { background-color: #fff0f0 } /* Literal.String.Heredoc */
pre.pygments .tok-si { background-color: #eeeeee } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #DD2200; background-color: #fff0f0 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #000000; background-color: #fff0ff } /* Literal.String.Regex */
pre.pygments .tok-s1 { background-color: #fff0f0 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #AA6600 } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0066BB; font-weight: bold } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #336699 } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #dd7700; font-weight: bold } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #3333BB } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #996633 } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #0000DD; font-weight: bold } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>PartiQL Specification</h1>
<div class="details">
<span id="author" class="author">The PartiQL Specification Committee</span><br>
<span id="revnumber"> v0.3.0-HEAD,</span>
<span id="revdate">2023-12-06</span>
<br><span id="revremark">PRE-RELEASE. See official releases at https://github.com/partiql/partiql-lang/releases</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Contents</div>
<ul class="sectlevel1">
<li><a href="#sec:introduction">1. Introduction</a></li>
<li><a href="#sec:model">2. Data Model</a></li>
<li><a href="#section:environment-and-sfw">3. Queries, Environments and Binding Tuples</a>
<ul class="sectlevel2">
<li><a href="#sec:syntax-basics">3.1. Basics of PartiQL Syntax</a></li>
<li><a href="#sec:environments-and-bindings">3.2. Environments</a></li>
<li><a href="#sec:clause-semantics">3.3. The semantics of each clause of an SFW query explained as input and output of binding tuples</a></li>
<li><a href="#sec:scoping-variables">3.4. Scoping Rules of Variables</a></li>
</ul>
</li>
<li><a href="#section:paths">4. Path Navigation</a>
<ul class="sectlevel2">
<li><a href="#sec:tuple-path-on-wrong">4.1. Tuple path evaluation on wrongly typed data</a>
<ul class="sectlevel3">
<li><a href="#sec:schema-in-tuple-path">4.1.1. Role of schema in type checking</a></li>
</ul>
</li>
<li><a href="#sec:array-on-wrong">4.2. Array navigation evaluation on wrongly typed data</a></li>
<li><a href="#sec:deep-navigation">4.3. Additional Path Syntax</a></li>
</ul>
</li>
<li><a href="#sec:from">5. <code>FROM</code> Clause Semantics</a>
<ul class="sectlevel2">
<li><a href="#sec:single-item-from">5.1. Ranging Over Bags and Arrays</a>
<ul class="sectlevel3">
<li><a href="#sec:bag-array-mistypings">5.1.1. Mistyping Cases</a></li>
</ul>
</li>
<li><a href="#sec:unpivot">5.2. Ranging over Attribute-Value Pairs</a>
<ul class="sectlevel3">
<li><a href="#sec:unpivot-mistypings">5.2.1. Mistyping Cases</a></li>
</ul>
</li>
<li><a href="#sec:combining-multiple-item-join">5.3. Combining Multiple <code>FROM</code> Items with Comma, <code>CROSS JOIN</code> , or <code>JOIN</code></a>
<ul class="sectlevel3">
<li><a href="#_associativity_of_cross_join">5.3.1. Associativity of <code>CROSS JOIN</code></a></li>
<li><a href="#_semantics">5.3.2. Semantics</a></li>
</ul>
</li>
<li><a href="#sec:combining-multiple-item-leftjoin">5.4. Combining Multiple Items with</a></li>
<li><a href="#sec:combining-multiple-item-full-outerjoin">5.5. Combining Multiple <code>FROM</code> Items with <code>FULL JOIN</code></a></li>
<li><a href="#sec:rewriting-on">5.6. Expanding <code>JOIN</code> and <code>LEFT JOIN</code> with <code>ON</code></a></li>
<li><a href="#sec:lateral">5.7. SQL’s <code>LATERAL</code></a></li>
</ul>
</li>
<li><a href="#sec:select-values">6. <code>SELECT</code> clauses</a>
<ul class="sectlevel2">
<li><a href="#sec:select-values-core">6.1. <code>SELECT VALUE</code> core clause</a>
<ul class="sectlevel3">
<li><a href="#sec:tuple-constructor">6.1.1. Tuple constructors</a>
<ul class="sectlevel4">
<li><a href="#_treatment_of_mistyped_attribute_names">6.1.1.1. Treatment of mistyped attribute names</a></li>
<li><a href="#_treatment_of_duplicate_attribute_names">6.1.1.2. Treatment of duplicate attribute names</a></li>
</ul>
</li>
<li><a href="#sec:array-constructor">6.1.2. Array Constructors</a></li>
<li><a href="#_bag_constructors">6.1.3. Bag Constructors</a></li>
<li><a href="#sec:treatment-missing-select-value">6.1.4. Treatment of <code>MISSING</code> in <code>SELECT VALUE</code></a>
<ul class="sectlevel4">
<li><a href="#_when_constructing_tuples">6.1.4.1. When constructing tuples</a></li>
<li><a href="#_when_constructing_arrays">6.1.4.2. When constructing arrays</a></li>
<li><a href="#_when_constructing_bags">6.1.4.3. When constructing bags</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec:pivot">6.2. Pivoting a Collection into a Variable-Width Tuple</a></li>
<li><a href="#sec:sql-select">6.3. SQL <code>SELECT</code> list as Syntactic Sugar of <code>SELECT VALUE</code></a>
<ul class="sectlevel3">
<li><a href="#sec:select-without-star">6.3.1. <code>SELECT</code> Without <code>*</code></a></li>
<li><a href="#sec:sql-star">6.3.2. SQL’s <code>*</code></a></li>
</ul>
</li>
<li><a href="#_examples_with_combinations_of_multiple_features">6.4. Examples with combinations of multiple features</a></li>
</ul>
</li>
<li><a href="#sec:preds-and-fns">7. Functions</a>
<ul class="sectlevel2">
<li><a href="#sec:fns-with-wrong-inputs">7.1. Inputs with wrong types:</a>
<ul class="sectlevel3">
<li><a href="#sec:equality">7.1.1. Equality</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec:where">8. <code>WHERE</code> clause</a></li>
<li><a href="#sec:subquery-coercion">9. Coercion of subqueries</a>
<ul class="sectlevel2">
<li><a href="#sec:select-coercion-scalar">9.1. Coercion of a <code>SELECT</code> subquery into a scalar</a></li>
<li><a href="#sec:select-coercion-array">9.2. Coercion of a <code>SELECT</code> subquery into an array</a></li>
</ul>
</li>
<li><a href="#sec:variable-scoping">10. Scoping rules</a>
<ul class="sectlevel2">
<li><a href="#_scoping_rules_resolving_naming_conflicts_between_variables_and">10.1. Scoping rules resolving naming conflicts between variables and</a></li>
</ul>
</li>
<li><a href="#section:groupby">11. <code>GROUP BY</code> clause</a>
<ul class="sectlevel2">
<li><a href="#sec:group-variable">11.1. PartiQL <code>GROUP BY</code> core: Grouping into a Group Variable</a>
<ul class="sectlevel3">
<li><a href="#sec:eqg">11.1.1. Equivalence function used by grouping; grouping of <code>NULL</code> and <code>MISSING</code></a></li>
<li><a href="#sec:group-all">11.1.2. The <code>GROUP ALL</code> variant</a></li>
</ul>
</li>
<li><a href="#sec:sql-groupby">11.2. SQL compatibility features</a>
<ul class="sectlevel3">
<li><a href="#sec:grouping-attributes">11.2.1. Grouping Attributes and Direct Use of Grouping Expressions</a></li>
<li><a href="#sec:implicit-group-variable">11.2.2. SQL&#8217;s Implicit Use of the Group Variable in SQL Aggregate Functions</a></li>
<li><a href="#sec:SQL-aggregation-functions">11.2.3. Designation of SQL aggregate functions</a></li>
<li><a href="#sec:select-aliases-groupby">11.2.4. Aliases from <code>SELECT</code> clause</a></li>
</ul>
</li>
<li><a href="#sec:windows-by-grouping">11.3. Windowing cases simplified by the PartiQL grouping</a></li>
</ul>
</li>
<li><a href="#section:order-by">12. <code>ORDER BY</code> clause</a>
<ul class="sectlevel2">
<li><a href="#sec:orderby-syntax">12.1. PartiQL Syntax</a></li>
<li><a href="#sec:order-by-less-than">12.2. The PartiQL order-by less-than function</a></li>
<li><a href="#sec:order-by-and-setops">12.3. Dependency of semantics on the Presence of Set Operators</a></li>
<li><a href="#sec:orderby-sql-compatibility">12.4. SQL Compatibility <code>ORDER BY</code> clauses</a></li>
<li><a href="#sec:select-variables-in-order">12.5. Use of <code>SELECT</code> variables in <code>ORDER BY</code> for SQL compatibility</a></li>
<li><a href="#sec:literal-conversion">12.6. Coercion of literals for SQL compatibility</a></li>
</ul>
</li>
<li><a href="#section:setop">13. <code>UNION</code> / <code>INTERSECT</code> / <code>EXCEPT</code> clauses</a></li>
<li><a href="#sec:pivot_clause">14. <code>PIVOT</code> Clause Semantics</a></li>
<li><a href="#sec:schema">15. Structural Types and Type-related Query Syntax and Semantics (WIP)</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<h2 id="_partiql_specification_license" class="discrete">PartiQL Specification License</h2>
<div class="paragraph">
<p>Copyright &#169; 2019 Amazon.com Inc. or Affiliates (&#8220;Amazon&#8221;).</p>
</div>
<div class="paragraph">
<p>This Agreement sets forth the terms under which Amazon is making the PartiQL Specification available to you.</p>
</div>
<h3 id="_copyrights" class="discrete">Copyrights</h3>
<div class="paragraph">
<p>Permission is hereby granted, free of charge, to you to use, copy, publish, and/or distribute, the Specification subject to the following conditions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The above copyright notice and this permission notice shall be included in all copies of the Specification.</p>
</li>
<li>
<p>You may not modify, merge, sublicense, and/or sell copies of the Specification.</p>
</li>
</ul>
</div>
<h3 id="_patents" class="discrete">Patents</h3>
<div class="paragraph">
<p>Subject to the terms and conditions of this Agreement, Amazon hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer implementations of the Specification that implement and are compliant with all relevant portions of the Specification (&#8220;Compliant Implementations&#8221;).
Notwithstanding the foregoing, no patent license is granted to any technologies that may be necessary to make or use any product or portion thereof that complies with the Specification but are not themselves expressly set forth in the Specification.</p>
</div>
<div class="paragraph">
<p>If you institute patent litigation against any entity (including a
cross-claim or counterclaim in a lawsuit) alleging that Compliant
Implementations of the Specification constitute direct or contributory
patent infringement, then any patent licenses granted to You under this
Agreement shall terminate as of the date such litigation is filed.</p>
</div>
<div class="paragraph">
<p>THE SPECIFICATION IS PROVIDED &#8220;AS IS&#8221;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL AMAZON BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SPECIFICATION, IMPLEMENTATIONS OF
THE SPECIFICATION, OR THE USE OR OTHER DEALINGS IN THE SPECIFICATION.</p>
</div>
<div class="paragraph">
<p>Any sample code included in the Specification, unless otherwise
specified, is licensed under the MIT No Attribution License.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:introduction"><a class="anchor" href="#sec:introduction"></a><a class="link" href="#sec:introduction">1. Introduction</a></h2>
<div class="sectionbody">
<h3 id="_draft_status" class="discrete">Draft Status</h3>
<div class="paragraph">
<p>This document is currently a working draft and subject to change.
Certain sections are marked as &#8220;work in progress&#8221; (WIP) and will be
expanded soon.</p>
</div>
<h3 id="_audience" class="discrete">Audience</h3>
<div class="paragraph">
<p>This document presents the formal syntax and semantics of PartiQL. It is
oriented to PartiQL query processor builders who need the full and
formal detail on PartiQL.</p>
</div>
<div class="paragraph">
<p>SQL users who are not interested in the full detail and the complete
formalism but are interested in learning how PartiQL extends SQL may
also read the tutorial. Unlike this formal specification, the tutorial
has a &#8220;how to&#8221; orientation and is primarily driven by examples.</p>
</div>
<h3 id="_partiql_core_and_partiql_syntactic_sugar" class="discrete">PartiQL core and PartiQL syntactic sugar</h3>
<div class="paragraph">
<p>In the interest of precision and succinctness, we tier the PartiQL
specification in two layers: The PartiQL core is a functional
programming language with composable aspects. Three aspects of the
PartiQL core syntax and semantics are characteristic of its functional
orientation: Every (sub)query and every (sub) expression input and
output PartiQL data. Second, each clause of a SELECT query is itself a
function. Third, every (sub)query evaluates within the environment
created by the database names and the variables of the enclosing
queries.</p>
</div>
<div class="paragraph">
<p>Then we layer &#8220;syntactic sugar&#8221; features over the core. Commonly,
syntactic sugar achieves well-known SQL syntax and semantics. Formally,
every syntactic sugar feature is explained by reduction to the core.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:model"><a class="anchor" href="#sec:model"></a><a class="link" href="#sec:model">2. Data Model</a></h2>
<div class="sectionbody">
<div id="figure:values:bnf" class="listingblock">
<div class="title">Listing 1. EBNF Grammar for PartiQL Values</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="ebnf"><span></span><span class="tok-k">value            </span><span class="tok-o">=</span> <span class="tok-k">absent_value</span>
                 <span class="tok-p">|</span> <span class="tok-k">scalar_value</span>
                 <span class="tok-p">|</span> <span class="tok-k">tuple_value</span>
                 <span class="tok-p">|</span> <span class="tok-k">collection_value </span><span class="tok-p">;</span>
<span class="tok-k">absent_value     </span><span class="tok-o">=</span> <span class="tok-s2">&quot;NULL&quot;</span>
                 <span class="tok-p">|</span> <span class="tok-s2">&quot;MISSING&quot;</span> <span class="tok-p">;</span>
<span class="tok-k">scalar_value     </span><span class="tok-o">=</span> <span class="tok-s2">&quot;`&quot;</span><span class="tok-p">,</span> <span class="tok-ni">? ion literal ?</span><span class="tok-p">,</span> <span class="tok-s2">&quot;`&quot;</span>
                 <span class="tok-p">|</span> <span class="tok-ni">? sql literal ?</span> <span class="tok-p">;</span>
<span class="tok-k">tuple_value      </span><span class="tok-o">=</span> <span class="tok-s2">&quot;{&quot;</span> <span class="tok-p">[</span> <span class="tok-k">string_value</span><span class="tok-p">,</span> <span class="tok-s2">&quot;:&quot;</span><span class="tok-p">,</span> <span class="tok-k">value </span><span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span><span class="tok-p">,</span> <span class="tok-k">string_value</span><span class="tok-p">,</span> <span class="tok-s2">&quot;:&quot;</span><span class="tok-p">,</span> <span class="tok-k">value </span><span class="tok-p">}]</span> <span class="tok-s2">&quot;}&quot;</span> <span class="tok-p">;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="tok-k">collection_value </span><span class="tok-o">=</span> <span class="tok-k">array_value</span>
                 <span class="tok-p">|</span> <span class="tok-k">bag_value </span><span class="tok-p">;</span>
<span class="tok-k">array_value      </span><span class="tok-o">=</span> <span class="tok-s2">&quot;[&quot;</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-k">value </span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span> <span class="tok-p">,</span> <span class="tok-k">value </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;]&quot;</span> <span class="tok-p">;</span>
<span class="tok-k">bag_value        </span><span class="tok-o">=</span> <span class="tok-s2">&quot;&lt;&lt;&quot;</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-k">value </span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span> <span class="tok-p">,</span> <span class="tok-k">value </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;&gt;&gt;&quot;</span> <span class="tok-p">;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>value</code> cannot be <code>MISSING</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#figure:values:bnf">Listing 1</a> shows the BNF grammar for PartiQL values.  A
PartiQL database generally contains one or more PartiQL <em>named
values</em>. A <em>name</em>, is an identifier, such as a table name, that is
associated with a PartiQL value.  <a href="#section:environment-and-sfw">Chapter 3</a>
defines what these names are, and how SQL qualified names work, in
detail.</p>
</div>
<div class="paragraph">
<p>The type of a value is <em>absent</em>, <em>scalar</em>, <em>tuple</em>, or <em>collection</em>.
Further subtyping applies to scalars, tuples, and collections.  We
will often use the name <em>complex value</em> to refer to any non-scalar and
non-absent value.  That is, complex values include <em>tuples</em> and
<em>collections</em>.  A tuple is a set of attribute name/value pairs, where
each name is a string (as in SQL).  A tuple in the data model is
unordered.  A conventional SQL tuple is an ordered tuple since the
schema dictates the order of the attributes and certain SQL operations
may use the order—support for this is described in detail in <a href="#sec:schema">Chapter 15</a>
<a href="#sec:schema">Chapter 15</a>.</p>
</div>
<div class="paragraph">
<p>PartiQL’s data model extends SQL to Ion’s type system to cover
schema-less and nested data.  Such values can be directly quoted with
<code><code></code>`</code> quotes.</p>
</div>
<div class="paragraph">
<p>Unlike SQL, PartiQL allows the possibility of duplicate attribute
names, in the interest of compatibility with non-strict JSON/Ion
datasets.  However PartiQL does not encourage duplicate attribute
names; navigation into tuples with the conventional dot notation
(<a href="#section:paths">Chapter 4</a>) is tuned to the assumption that the attribute
names are unique.</p>
</div>
<div class="paragraph">
<p>A <em>collection_value</em> is either an ordered or unordered (EBNF lines
10-11) <em>collection</em>. Both arrays and bags may contain duplicate
elements. An array is ordered (similar to a JSON array or Ion list)
and each element is accessible by its ordinal position.  (See
specifics of access by position in <a href="#section:paths">Chapter 4</a>.) Arrays are
delimited with <code>[</code> and <code>]</code>.  For example, the value of the attribute
<code>configurationItems</code> in <a href="#figure:values:example-value">Listing 2</a> is an
array. Arrays have size, which is not explicitly denoted but is
implied by the number of elements in the array. For example, the size
of the <code>configurationItems</code> in <a href="#figure:values:example-value">Listing 2</a> is 2.
The first element of an array corresponds to index 0; the last element
corresponds to index size minus one.</p>
</div>
<div class="paragraph">
<p>In contrast, a bag is unordered (similar to a SQL table) and its
elements cannot be accessed by ordinal position. Bags are denoted with
and <code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Finally, note that PartiQL has two kinds of absent values:`NULL` and
<code>MISSING</code>. The motivation is as follows: Unlike SQL, where a query
that refers to a non-existent attribute name is expected to fail
during compilation, in semi-structured data one expects a query to
operate even if some of the tuples do not define some of the
attributes that the query’s paths mention. Hence PartiQL contains the
special value <code>MISSING</code> (EBNF line 6), which is the path result in
cases where navigation fail to bind to any information. The
distinction between <code>MISSING</code> and <code>NULL</code> enables retaining the
original distinction between a missing attribute and a null-valued
attribute. The utility of <code>MISSING</code> (as opposed to just having <code>NULL</code>)
will become further apparent when navigation into semi-structured data
and construction of semi-structured results is discussed.</p>
</div>
<div class="paragraph">
<p>The value <code>MISSING</code> may not appear as an attribute value. Notice that
in the interest of readability, the syntax of <a href="#figure:values:bnf">Listing 1</a>
does exclude these cases; rather the &#8220;<code><code>value</code></code> cannot be <code>MISSING</code>&#8221;
call-out indicates that <code>MISSING</code> cannot appear as an attribute value.</p>
</div>
<h3 id="_comparisons_to_the_relational_model" class="discrete">Comparisons to the relational model</h3>
<div class="paragraph">
<p>In summary, the PartiQL data model extended the SQL data model in the
following ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The elements of an array/bag can be any kind of value—not just
tuples.  Furthermore they can be heterogeneous. That is, there are no
restrictions between the elements of an array/bag. For example, the
two tuples in <code>configurationItems</code> array of are <em>heterogeneous</em>
because: (i) each tuple has a different set of attributes (for
example, the second tuple has <code>configurationStateId</code> while the first
does not), (ii) an attribute of a first tuple may map to some type
while the same attribute in a second tuple may map to another type.</p>
</li>
<li>
<p>More broadly, unlike SQL where the values are tables that have
homogeneous tuples that have scalars, PartiQL complex values are
<em>arbitrary compositions of arrays, bags and tuples</em>. E.g., the top
level value of <a href="#figure:values:example-value">Listing 2</a> is a tuple and the
<code>configurationItems</code> array has two heterogeneous tuples.  Note that in
this example, the top-level name refers to a value that is <em>not</em> a bag
(e.g. a table).</p>
</li>
<li>
<p>There is a distinction between null-valued attributes and missing
attributes.</p>
</li>
<li>
<p>PartiQL makes an explicit distinction between arrays and bags,
where the former have order and their elements can be addressed by
ordinal position. <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
</ol>
</div>
<div id="figure:values:example-value" class="listingblock">
<div class="title">Listing 2. An Example of a PartiQL Value</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><div class="lineno"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span></pre></div></td><td class="code"><div><pre><span></span>{
  &#39;fileVersion&#39;:&#39;1.0&#39;,
  &#39;configurationItems&#39;:[
    {
        &#39;configurationItemCaptureTime&#39;: `2016-08-03T08:56:52.415Z`,
        &#39;resourceId&#39;:&#39;h-0337bfe6793cf9e0c&#39;,
        &#39;configuration&#39;:{
          &#39;hostId&#39;:&#39;h-0337bfe6793cf9e0c&#39;,
          &#39;hostProperties&#39;:{
              &#39;sockets&#39;:2,
              &#39;cores&#39;:20,
              &#39;totalVCpus&#39;:32,
              &#39;instanceType&#39;:&#39;m4.medium&#39;
          },
        &#39;tags&#39;:{
          &#39;CostCenter&#39;:&#39;Prod&#39;
        },
    },
    {
        &#39;configurationItemCaptureTime&#39;:`2016-08-03T09:41:56.906Z`,
        &#39;resourceId&#39;:&#39;h-0337bfe6793cf9e0c&#39;,
        &#39;configurationStateId&#39;:3,
        &#39;configuration&#39;:{
          &#39;hostId&#39;:&#39;h-0337bfe6793cf9e0c&#39;,
          &#39;autoPlacement&#39;:&#39;off&#39;,
          &#39;hostProperties&#39;:{
              &#39;sockets&#39;:2,
              &#39;cores&#39;:20,
              &#39;totalVCpus&#39;:32,
              &#39;instanceType&#39;:&#39;m3.medium&#39;
          },
        &#39;tags&#39;:{
        },
    }
  ]
}
</pre></div></td></tr></table></div></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section:environment-and-sfw"><a class="anchor" href="#section:environment-and-sfw"></a><a class="link" href="#section:environment-and-sfw">3. Queries, Environments and Binding Tuples</a></h2>
<div class="sectionbody">
<div id="figure:query:bnf" class="listingblock">
<div class="title">Listing 3. EBNF Grammar for PartiQL Queries</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="ebnf"><div class="lineno"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><span class="tok-k">query </span><span class="tok-o">=</span> <span class="tok-k">sfw_query</span>
      <span class="tok-p">|</span> <span class="tok-k">expr_query </span><span class="tok-p">;</span>
<span class="tok-k">sfw_query </span><span class="tok-o">=</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;WITH&quot;</span><span class="tok-p">,</span> <span class="tok-k">query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;AS&quot;</span><span class="tok-p">,</span> <span class="tok-k">variable </span><span class="tok-p">],</span>
            <span class="tok-k">select_clause</span><span class="tok-p">,</span>
            <span class="tok-k">from_clause</span><span class="tok-p">,</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;WHERE&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">],</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;GROUP&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;BY&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;AS&quot;</span><span class="tok-p">,</span> <span class="tok-k">variable </span><span class="tok-p">],</span>
                       <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;AS&quot;</span><span class="tok-p">,</span> <span class="tok-k">variable </span><span class="tok-p">]</span> <span class="tok-p">},</span>
                       <span class="tok-s2">&quot;GROUP&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;AS&quot;</span><span class="tok-p">,</span> <span class="tok-k">variable</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;HAVING&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">],</span>
            <span class="tok-p">[</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;OUTER&quot;</span> <span class="tok-p">],</span> <span class="tok-p">(</span> <span class="tok-s2">&quot;UNION&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;INTERSECT&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;EXCEPT&quot;</span> <span class="tok-p">),</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;ALL&quot;</span> <span class="tok-p">]</span> <span class="tok-k">sfw_query </span><span class="tok-p">],</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;ORDER&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;BY&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;ASC&quot;</span> <span class="tok-p">|</span> <span class="tok-s2">&quot;DESC&quot;</span> <span class="tok-p">],</span> <span class="tok-p">[</span> <span class="tok-k">order_spec </span><span class="tok-p">],</span>
                       <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;ASC&quot;</span> <span class="tok-p">|</span> <span class="tok-s2">&quot;DESC&quot;</span> <span class="tok-p">],</span> <span class="tok-p">[</span> <span class="tok-k">order_spec </span><span class="tok-p">]</span> <span class="tok-p">},</span>
                       <span class="tok-p">[</span> <span class="tok-s2">&quot;GROUP&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;AS&quot;</span><span class="tok-p">,</span> <span class="tok-k">variable </span><span class="tok-p">],</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;LIMIT&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">],</span>
            <span class="tok-p">[</span> <span class="tok-s2">&quot;OFFSET&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">]</span> <span class="tok-p">;</span>
<span class="tok-k">expr_query </span><span class="tok-o">=</span> <span class="tok-s2">&quot;(&quot;</span><span class="tok-p">,</span> <span class="tok-k">sfw_query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;)&quot;</span>
           <span class="tok-p">|</span> <span class="tok-k">path_expr</span>
           <span class="tok-p">|</span> <span class="tok-k">function_name</span><span class="tok-p">,</span> <span class="tok-s2">&quot;(&quot;</span><span class="tok-p">,</span> <span class="tok-p">[</span><span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;)&quot;</span>
           <span class="tok-p">|</span> <span class="tok-s2">&quot;{&quot;</span> <span class="tok-p">[</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;:&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;:&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;}&quot;</span>
           <span class="tok-p">|</span> <span class="tok-s2">&quot;[&quot;</span> <span class="tok-p">[</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;]&quot;</span>
           <span class="tok-p">|</span> <span class="tok-s2">&quot;&lt;&lt;&quot;</span> <span class="tok-p">[</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query </span><span class="tok-p">}</span> <span class="tok-p">],</span> <span class="tok-s2">&quot;&gt;&gt;&quot;</span>
           <span class="tok-p">|</span> <span class="tok-ni">? sql scalar expression ?</span>
           <span class="tok-p">|</span> <span class="tok-k">value_constant </span><span class="tok-p">;</span>
<span class="tok-k">path_expr </span><span class="tok-o">=</span> <span class="tok-k">variable</span>
          <span class="tok-p">|</span> <span class="tok-s2">&quot;(&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;)&quot;</span>
          <span class="tok-p">|</span> <span class="tok-k">path_expr</span><span class="tok-p">,</span> <span class="tok-s2">&quot;.&quot;</span><span class="tok-p">,</span> <span class="tok-k">attr_name</span>
          <span class="tok-p">|</span> <span class="tok-k">path_expr</span><span class="tok-p">,</span> <span class="tok-s2">&quot;[&quot;</span><span class="tok-p">,</span> <span class="tok-k">expr_query</span><span class="tok-p">,</span> <span class="tok-s2">&quot;]&quot;</span>
          <span class="tok-p">|</span> <span class="tok-k">path_expr</span><span class="tok-p">,</span> <span class="tok-s2">&quot;.&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;*&quot;</span>
          <span class="tok-p">|</span> <span class="tok-k">path_expr</span><span class="tok-p">,</span> <span class="tok-s2">&quot;[&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;*&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;]&quot;</span> <span class="tok-p">;</span>
</pre></div></td></tr></table></div></code></pre>
</div>
</div>
<div class="paragraph">
<p>PartiQL may be seen as a functional programming language with composable
semantics. Three aspects of the PartiQL syntax and semantics are
characteristic of its functional orientation: First, every (sub-)query
and every (sub-)expression input and output PartiQL data. Second, each
clause of an SFW query (<code>SELECT</code>-<code>FROM</code>-<code>WHERE</code>) is itself a function. Third, every
(sub-)query evaluates within an <em>environment</em> created by the database
names and the variables of the enclosing queries.</p>
</div>
<div class="sect2">
<h3 id="sec:syntax-basics"><a class="anchor" href="#sec:syntax-basics"></a><a class="link" href="#sec:syntax-basics">3.1. Basics of PartiQL Syntax</a></h3>
<div class="paragraph">
<p>A PartiQL query is either an <em>SFW query</em> (i.e. <code>SELECT-FROM-WHERE</code>&#8230;&#8203;,
(lines 3-16) the grammar of <a href="#figure:query:bnf">Listing 3</a>) or an <em>expression
query</em> (also called <em>simple expression</em> in the rest,
&lt;&lt;#figure:query:bnf&gt; lines 17-30) such as a path expression (
&lt;&lt;#figure:query:bnf&gt; lines 25-30) or a function invocation. Unlike SQL
expressions, which are restricted to outputting scalar and null
values, PartiQL expressions output arbitrary PartiQL values, and are
fully composable within larger SFW queries and expressions. Indeed,
PartiQL allows the top-level query to also be an expression query, not
just a SFW query as in SQL.</p>
</div>
<div class="paragraph">
<p>An PartiQL (sub)query is evaluated within an environment, which provides
variable bindings (as defined next).</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:environments-and-bindings"><a class="anchor" href="#sec:environments-and-bindings"></a><a class="link" href="#sec:environments-and-bindings">3.2. Environments</a></h3>
<div id="figure:names:bnf" class="listingblock">
<div class="title">Listing 4. EBNF Grammar for PartiQL Names</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="ebnf"><div class="lineno"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><span class="tok-k">bind_name </span><span class="tok-o">=</span> <span class="tok-k">global_name</span>
          <span class="tok-p">|</span> <span class="tok-k">variable </span><span class="tok-p">;</span>
<span class="tok-k">qualified_name </span><span class="tok-o">=</span> <span class="tok-k">identifier</span><span class="tok-p">,</span> <span class="tok-s2">&quot;.&quot;</span><span class="tok-p">,</span> <span class="tok-k">identifier</span><span class="tok-p">,</span> <span class="tok-p">{</span> <span class="tok-s2">&quot;.&quot;</span><span class="tok-p">,</span> <span class="tok-k">identifier </span><span class="tok-p">}</span> <span class="tok-p">;</span>
<span class="tok-k">variable_name </span><span class="tok-o">=</span> <span class="tok-k">identifier </span><span class="tok-p">;</span>
<span class="tok-k">identifier </span><span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-s2">&quot;$&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;_&quot;</span><span class="tok-p">|</span><span class="tok-k">letter</span><span class="tok-p">),</span> <span class="tok-p">{</span> <span class="tok-p">(</span><span class="tok-s2">&quot;$&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;_&quot;</span><span class="tok-p">|</span><span class="tok-k">letter</span><span class="tok-p">|</span><span class="tok-k">digit</span><span class="tok-p">)</span> <span class="tok-p">}</span>
           <span class="tok-p">|</span> <span class="tok-s1">&#39;&quot;&#39;</span><span class="tok-p">,</span> <span class="tok-ni">? quoted identifier body ?</span><span class="tok-p">,</span> <span class="tok-s1">&#39;&quot;&#39;</span> <span class="tok-p">;</span>
</pre></div></td></tr></table></div></code></pre>
</div>
</div>
<div class="paragraph">
<p>Each PartiQL (sub-)query and PartiQL (sub-)expression \$q\$ is
evaluated within the <em>database environment</em> \$p_0\$ created by the
database names and the <em>variables environment</em> \$p\$ created by the
defined query variables. The pair of these environments, \$(p_0, p)\$ is
collectively called the <em>bindings environment</em>.</p>
</div>
<div class="paragraph">
<p>In either case, an environment is a <em>binding tuple</em>
\$&lt;&lt;x_1:v_1,...,x_n:v_n&gt;&gt;\$, where each \$x_i\$ is a <em>bind name</em>
(<a href="#figure:names:bnf">Listing 4</a> lines 1-6) that is unique and binds to the
PartiQL <em>value</em> \$v_i\$.  The two distinct environments may also be
thought of as <em>global</em> (the database object names) and <em>local</em> (the
lexically defined variables in a particular scope of the query).</p>
</div>
<div class="paragraph">
<p>Similarly, for a given \$q\$ at compile (i.e. planning) time, a
<em>database type environment</em>, \$Gamma_0\$, and <em>variables type
environment</em>, \$Gamma\$ are defined. The type environment is a
<em>binding tuple</em> \$&lt;&lt;x_1:tau_1,...,x_n:tau_n&gt;&gt;\$ , where each
\$x_i\$ is a <em>name</em> that is unique and binds to the PartiQL <em>type</em>
\$tau_i\$. For schema-less values, \$tau\$ can be considered the
union of any possible type (for which all operations are <em>potentially</em>
applicable). This is discussed in more detail in <a href="#sec:schema">Chapter 15</a>.</p>
</div>
<div class="paragraph">
<p><em>Qualified names</em> (<a href="#figure:names:bnf">Listing 4</a> line 3) only ever appear in
the <em>database environment</em>.  Lexically defined <em>variable names</em>
(<a href="#figure:names:bnf">Listing 4</a> line 4) are always just simple identifiers
(<a href="#figure:names:bnf">Listing 4</a> lines 5-6). For example, a relational database
might define a compound name <code>mydb.log</code>, where <code>mydb</code> is the schema
(and not actually a value) and <code>log</code> could be a table name within that
schema. Note, that a qualified name is distinct from a quoted
identifier that contains a dot. Thus, the qualified name <code>mydb.log</code> is
distinct from the bind name <code>"mydb.log"</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Let us assume that we evaluate the following query on the database of
<a href="#figure:values:example-value">Listing 2</a>, whose top-level value is named
<code>mydb.log</code>.</p>
</div>
<div id="listing:x1" class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT x.resourceId
FROM mydb.log.configurationItems x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query is evaluated within the database environment \$p_0 =
&lt;&lt;"mydb.log : { 'fileversion': '1.0', 'configurationItems': ...  }"&gt;&gt;\$
and the variables environment \$p_1 = &lt;&lt;&gt;&gt;\$.  Notice the database
environment \$p_0\$ has a single name/value pair, which corresponds
to the only name (<code>mydb.log</code>) of the database of
<a href="#figure:values:example-value">Listing 2</a>.  The variables environment has no
name/value pair because the above query is not a subquery of a larger
query.</p>
</div>
<div class="paragraph">
<p>Next, consider the subexpression <code>x.resourceId</code> of the example’s
query. This subexpression will, generally, be evaluated many times -
once for each <code>x</code>.  Technically, each time it is evaluated within the
same database environment \$p_0\$ and within a variables
environment \$p_2 = (: x : ... :)\$, i.e., a variables environment
that defines the variable <code>x</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><strong>Remark on relationship of binding tuples to PartiQL tuples</strong> A binding
tuple is similar to a PartiQL tuple, if you think of the bind names as
attribute names. The characterization &#8220;binding&#8221; pertains to its use in
the semantics (e.g. an association of names to types) and the fact that
qualified names are not reified in the PartiQL data model, and we have a
representation. As we will see collections of binding tuples will be
homogenous, i.e., they will all have the same &#8220;attribute&#8221; names. Also
important, is that when we represent binding tuples we explicitly
represent a variable with a <code>MISING</code> value, as opposed to omitting it because
the lack of a variable name is distinct from a variable whose value is <code>MISSING</code>.
For example, we write \$&lt;&lt;x : 1, y: "MISSING"&gt;&gt;\$ instead of \$&lt;&lt;x : 1&gt;&gt;\$.</p>
</div>
<div class="paragraph">
<p><strong>Evaluation in environment</strong> The notation \$(p_0,p) |-- q -&gt; v\$
denotes that the PartiQL query \$q\$ evaluates to the value
\$v\$ when evaluated within the database environment \$p_0\$ and
the variables environment \$p\$, i.e. when every variable of
\$q\$ is instantiated by its binding in \$p\$ and each database
name is instantiated to its value in \$p_0\$. For example, consider
the query <code>x + y / 2</code>, the database environment \$p_0 = &lt;&lt;x:5&gt;&gt;\$
and the variables environment \$p = &lt;&lt;y:3&gt;&gt;\$. Then
\$(p_0,p) |-- "(x+y)/2" -&gt; "5+3/2" -&gt; 4\$.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:clause-semantics"><a class="anchor" href="#sec:clause-semantics"></a><a class="link" href="#sec:clause-semantics">3.3. The semantics of each clause of an SFW query explained as input and output of binding tuples</a></h3>
<div class="paragraph">
<p>The semantics of PartiQL are shorter than the semantics of SQL
itself—despite being backwards compatible with SQL. The key reason is
that the semantics of each clause of an SFW query in the PartiQL core
can be understood in isolation from the other clauses. A clause is
simply a function that inputs and outputs binding tuples. Thus the
specifics of how the binding tuples of a query and of its subqueries are
produced are a central part of the semantics. At a high level (which
will be elaborated upon later) the construction of binding environments
proceeds as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When a query is submitted to a database, it is evaluated in an empty
variables environment \$p = &lt;&lt;&gt;&gt;\$</p>
</li>
<li>
<p>The <code>FROM</code> clause of a SFW query produces new environments by concatenating
bindings of the <code>FROM</code> variables to the environment of its SFW query, as
explained below.</p>
<div class="paragraph">
<p>The subqueries that appear in the <code>WHERE</code>, <code>SELECT</code>, etc clauses are evaluated in these
new environments. The optional <code>GROUP BY</code> clause also produces additional variable
bindings, as explained in <a href="#section:groupby">Chapter 11</a>.</p>
</div>
</li>
</ol>
</div>
<div id="xmpl:sfw_bindings" class="exampleblock">
<div class="title">Example 2. An Example SFW Query with Flow of Binding Tuples</div>
<div class="content">
<div class="paragraph">
<p>\$p_0: &lt;&lt; "mydb.r" : \[ 3, 'x'], "mydb.s" : &lt; &lt; {'a':1, 'b': 2}, {'a': 3} &gt; &gt; &gt;&gt; \$<br>
\$p = &lt;&lt;&gt;&gt;\$</p>
</div>
<div class="paragraph">
<p><code>FROM mydb.r AS x, mydb.s AS y</code><br>
\$B_"FROM"^"out" = B_"WHERE"^"in" = \$<br>
\$&lt; &lt;\$<br>
\$  &lt;&lt;x:3, y:{'a':1, 'b':2}&gt;&gt;\$<br>
\$  &lt;&lt;x:3, y:{'a':3}&gt;&gt;\$<br>
\$  &lt;&lt;x:'x', y:{'a':1, 'b':2}&gt;&gt;\$<br>
\$  &lt;&lt;x:'x', y:{'a':3}&gt;&gt;\$<br>
\$&gt; &gt;\$</p>
</div>
<div class="paragraph">
<p><code>WHERE x &gt; y.b</code><br>
\$B_"WHERE"^"out" = B_"SELECT"^"in" = \$<br>
\$&lt; &lt;\$ \$&lt;&lt;x:3, y:{'a':1, 'b':2}&gt;&gt;\$ \$&gt; &gt;\$</p>
</div>
<div class="paragraph">
<p><code>SELECT x AS foo, y.a AS bar</code><br>
\$"Result" = &lt; &lt; &lt;&lt;{"foo":3, "bar":1}&gt;&gt; &gt; &gt;\$</p>
</div>
</div>
</div>
<h4 id="_sfw_query_clauses_as_operators_that_inputoutput_binding_tuples" class="discrete">SFW query clauses as operators that input/output binding tuples</h4>
<div class="paragraph">
<p>Similar to SQL semantics, the clauses of an PartiQL SFW query are
evaluated in the following order: <code>WITH</code>, <code>FROM</code>, <code>LET</code>, <code>WHERE</code>,
<code>GROUP BY</code>, <code>HAVING</code>, <code>LETTING</code> (which is special to PartiQL), <code>ORDER
BY</code>, <code>LIMIT</code>/<code>OFFSET</code>, and <code>SELECT</code> (or <code>SELECT VALUE</code> or <code>PIVOT</code>,
which are both special to ion PartiQL).  <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p>
</div>
<div class="paragraph">
<p>Using the example of <a href="#xmpl:sfw_bindings">Example 2</a>, we illustrate how the
clauses of an SFW query input and output binding tuples. In the
<a href="#xmpl:sfw_bindings">Example 2</a>, the <code>FROM</code>, <code>WHERE</code>, and <code>SELECT</code> clauses
of the example query are displayed apart from each other so that the
example can also illustrate the binding tuples that flow from the one
clause to the next.</p>
</div>
<div class="paragraph">
<p>The query is evaluated within the bindings environment \$(p_0, p)\$
shown at the top of <a href="#xmpl:sfw_bindings">Example 2</a>. Consequently, the
<code>FROM</code> clause is evaluated in the same environment. Thereafter the
<code>FROM</code> clause outputs the bag of binding tuples \$B_"FROM"^"out"\$,
which has four binding tuples in the example. In each binding tuple of
\$B_"FROM"^"out"\$ , each variable of the <code>FROM</code> clause is bound to
a value. There are no restrictions that a variable binds to homogenous
values across binding tuples. In the example, <code>x</code> binds to two values
that are heterogeneous: some bindings of <code>x</code> bind to a number, while
others to a string. It would also be possible that a variable binds
to, say, a scalar in one binding, while the same variable binds to a
complex value in another binding.</p>
</div>
<div class="paragraph">
<p>Each subsequent clause inputs a bag of binding tuples, evaluates the
constituent expressions of the clause (which may themselves contain
nested SFW queries), and outputs a bag of binding tuples that is in
turn input by the next clause. For instance, the <code>WHERE</code> clause inputs
the bag of binding tuples that have been output by the <code>FROM</code> clause
(\$B_"FROM"^"out" = B_"WHERE"^"in"\$), and outputs the subset
thereof that satisfies the condition expression of the <code>WHERE</code>
clause. This subset is the \$B_"WHERE"^"out" = B_"SELECT"^"in"\$.</p>
</div>
<div class="paragraph">
<p>In particular, the <code>WHERE</code>’s condition is evaluated once for each
input binding tuple \$b\$ in \$B_"WHERE"^"in"\$. In general,
each evaluation is done within the bindings environment
\$(p_0,p || b)\$ , i.e., the concatenation of the binding tuple
\$p\$ (where \$p\$ is the binding environment of the SFW query)
with the binding tuple \$b\$ that has the variables of the
clause. In the particular example \$p || b\$ is simply \$b\$
since \$p=&lt;&lt;&gt;&gt;\$. The condition is evaluated once for each of the
four input binding tuples of \$B_"WHERE"^"in"\$. The variables
environment of the first evaluation is:</p>
</div>
<div class="paragraph">
<p>\$p = &lt;&lt;x:3, y: { 'a':1, 'b':2 } &gt;&gt;\$</p>
</div>
<div class="paragraph">
<p>The condition evaluates to for the first binding tuple of
\$B_"WHERE"^"in"\$, since</p>
</div>
<div class="paragraph">
<p>\$(p_0,p) |-- x &gt; y.b -&gt; 3 &gt; { 'a':1, 'b':3}.b -&gt; true \$</p>
</div>
<div class="paragraph">
<p>Thus the first binding tuple of \$B_"WHERE"^"in"\$ is
output from the <code>WHERE</code> and is input to <code>SELECT</code>.</p>
</div>
<div class="paragraph">
<p>The pattern of &#8220;input bag of binding tuples, evaluate constituent
expressions, output bag of binding tuples&#8221; has a few exceptions:
First, the <code>ORDER BY</code> clause inputs a bag of binding tuples and
outputs an array of binding tuples. Second, a <code>LIMIT</code>/<code>OFFSET</code> clause
need not evaluate its constituent expression for each input binding
tuple. For example a <code>LIMIT 10</code> clause that inputs an array with 100
binding tuples need not access binding tuples 11-100.</p>
</div>
<div class="paragraph">
<p>Finally, the <code>SELECT</code> clause is responsible for converting from
binding tuples to collections of arbitrary PartiQL elements. The
<code>SELECT</code> inputs a bag (or array, if <code>ORDER BY</code> is present) of binding
tuples, and outputs the SFW query’s result, which is a bag
(resp. array) with exactly one element for each input binding
tuple. In the example, the <code>SELECT</code> expressions <code>x</code> and <code>y.a</code> are
evaluated once for each of the input binding tuples of
\$B_"SELECT"^"in"\$, which in this example happen to be just one
binding tuple.</p>
</div>
<div class="paragraph">
<p>Finally, notice that the above discussion of SFW queries did not
capture the set operators <code>UNION</code>, <code>INTERSECT</code>, and <code>EXCEPT</code>. As is
the case with SQL semantics too, the coordination of with the set
operators requires attention.</p>
</div>
<h4 id="_partiql_clauses_as_operators" class="discrete">PartiQL clauses as operators</h4>
<div class="paragraph">
<p>In summary, each clause of PartiQL is an operator that inputs/outputs
binding tuples. As such, we can (and will) present the semantics of
each clause separately from the semantics of the other clauses. This
is not the case in SQL: Notably, in the presence of aggregation
functions the <code>SELECT</code>, <code>HAVING</code>, and <code>WHERE</code> cannot be interpreted in
isolation; they can only be interpreted along with the <code>GROUP BY</code>
clause.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:scoping-variables"><a class="anchor" href="#sec:scoping-variables"></a><a class="link" href="#sec:scoping-variables">3.4. Scoping Rules of Variables</a></h3>
<div class="paragraph">
<p>As in any programming language, the PartiQL semantics have to deal
with issues of variable scope. For example, how are references to <code>x</code>
resolved in the following query:</p>
</div>
<div id="figure:x2" class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT x.a AS a
FROM db1 AS x
WHERE x.b IN (SELECT x.c FROM db2 AS x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this is an SQL query and PartiQL is backwards compatible to SQL,
it is easy to tell that the <code>x</code> in <code>x.c</code> resolves to the variable
defined by the inner query’s <code>FROM</code> clause.</p>
</div>
<div class="paragraph">
<p>Technically, this scoping rule is captured by the following handling
of binding tuples. The inner <code>FROM</code> clause is evaluated with a
variables environment \$p = &lt;&lt;x:...&gt;&gt;\$; its <code>x</code> is the one defined
by the outer <code>FROM</code>. Then the inner <code>FROM</code> clause outputs a binding
\$b = &lt;&lt;x..&gt;&gt;\$; this <code>x</code> is defined by thinner <code>FROM</code>. Then the
<code>x.c</code> is evaluated in the concatenation \$p||b\$ and because <code>x</code>
appears in both \$p\$ and \$b\$, the concatenation keeps only
the <code>x</code> of its right argument. Essentially by putting \$b\$ as the
right argument of the concatenation, the semantics indicate that the
variables of \$b\$ have precedence over synonymous variables in the
left argument (which was the \$p\$).</p>
</div>
<div class="paragraph">
<p>Generally, given two binding tuples \$b\$ and \$b'\$, their
concatenation is a binding tuple, denoted as \$b||b'\$, that has
the variable bindings of both \$b\$ and \$b'\$. This creates the
possibility that both \$b\$ and \$b'\$ have the same variable
\$x\$. In this case, the concatenation \$b||b'\$ will have the
\$b'.x\$ and its value; it will not have the \$b.x\$ and its
value.</p>
</div>
<div class="paragraph">
<p>Note, the above does not resolve scoping issues resulting from conflicts
between the database environment and the variables environment. We
resolve these conflicts by explicit rules.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section:paths"><a class="anchor" href="#section:paths"></a><a class="link" href="#section:paths">4. Path Navigation</a></h2>
<div class="sectionbody">
<h4 id="_tuple_path_navigation" class="discrete">Tuple path navigation</h4>
<div class="paragraph">
<p>A <em>tuple path navigation</em> \$t.a\$ from the tuple \$t\$ to its
attribute \$a\$ (<a href="#figure:query:bnf">Listing 3</a> line 27) returns the value
of the attribute \$a\$. (We discuss below the corner case where a
tuple has multiple attributes <code>a</code>.) \$t\$ is an expression but
\$a\$ is always an identifier (<a href="#figure:names:bnf">Listing 4</a> lines
5-6). For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;: 1, &#39;b&#39;:2}.a</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;: 1, &#39;b&#39;: 2}.&quot;a&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Even if there were a variable <code>a</code>, bound to <code>'b'</code>, the result of the
above expression would still be <code>1</code>, because the identifier <code>a</code> (or
<code>"a"</code>) is interpreted as the "`look for the attribute named <code>a</code> `"
when it follows the dot in a tuple path navigation. The semantics of
tuple path navigation do not depend on whether the tuple is ordered or
unordered by schema.</p>
</div>
<h4 id="_array_navigation" class="discrete">Array navigation</h4>
<div class="paragraph">
<p>An <em>array navigation</em> \$a\[i]\$ returns the \$i\$-th element
<em>when</em> it is applied on an array \$a\$ (<a href="#figure:query:bnf">Listing 3</a> line
28) and \$i\$ is an expression that evaluates into an integer. Both
\$a\$ and \$i\$ are expressions. For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>[2, 4, 6][1+1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>6</code></pre>
</div>
</div>
</div>
</div>
<h4 id="_tuple_navigation_with_array_notation" class="discrete">Tuple navigation with array notation</h4>
<div class="paragraph">
<p>The expression \$a\[s]\$ is a shorthand for the tuple path
navigation \$a.s\$ when the expression \$s\$ is either (a) a
string literal or (b) an expression that is explicitly <code>CAST</code> into a
string. For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;: 1, &#39;b&#39;: 2}[&#39;a&#39;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;: 1, &#39;b&#39;: 2}.&#39;a&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;attr&#39;: 1, &#39;b&#39;:2}[CAST(&#39;at&#39; || &#39;tr&#39; AS STRING)]</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>1</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If \$s\$ is not a string literal or an expression that is cast into
a string, then \$a\[s]\$ is evaluated as an array path
navigation. Notice that in the absence of an explicit cast, the
navigation \$a\[e]\$ evaluates as an array navigation, even if
\$e\$ ends up evaluating to a string. For example, let us assume
that the variable <code>v</code> is bound to <code>at</code> and the variable <code>w</code> is bound
to <code>tr</code>.  Still, the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;attr&#39;: 1, &#39;b&#39;:2}[v || w]</code></pre>
</div>
</div>
<div class="paragraph">
<p>does not evaluate to <code>1</code>. It is treated as an array navigation with wrongly
typed index and it will return <code>MISSING</code>, for reasons explained below.</p>
</div>
<h4 id="_composition_of_navigations" class="discrete">Composition of navigations</h4>
<div class="paragraph">
<p>Notice that consecutive tuple/array navigations (e.g. <code>r.no[1]</code>)
navigate deeply into complex values. Notice further that paths
consisting of plain tuple and array path navigations evaluate to a
unique value.</p>
</div>
<h4 id="_tuple_navigation_in_tuples_with_duplicate_attributes" class="discrete">Tuple navigation in tuples with duplicate attributes</h4>
<div class="paragraph">
<p>When the tuple <code>t</code> has multiple attributes <code>a</code>, the tuple path navigation <code>t.a</code> will
return the first instance of <code>a</code>. Note that for tuples whose order is
defined by schema, this is well-defined, for unordered tuples, it is
implementation defined which attribute is returned in <em>permissive mode</em>
or an error in <em>type checking mode</em>, which is described in
<a href="#sec:tuple-path-on-wrong">Section 4.1</a>.</p>
</div>
<div class="paragraph">
<p>If one wants to access all instances of <code>a</code>, she should use the
<code>UNPIVOT</code> feature instead (see <a href="#sec:unpivot">Section 5.2</a>). For example, the
following query returns the list of all <code>a</code> values in a tuple <code>t</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v
FROM UNPIVOT t AS v AT attr
WHERE attr = &#39;a&#39;</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="sec:tuple-path-on-wrong"><a class="anchor" href="#sec:tuple-path-on-wrong"></a><a class="link" href="#sec:tuple-path-on-wrong">4.1. Tuple path evaluation on wrongly typed data</a></h3>
<div class="paragraph">
<p>In the case of tuple paths, since PartiQL does not assume a schema, the
semantics must also specify the return value when:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>\$t\$ is not a tuple (i.e., when the expression \$t\$ does
not evaluate into a tuple), or</p>
</li>
<li>
<p>\$t\$ is a tuple that does not have an \$a\$ attribute.</p>
</li>
</ol>
</div>
<h4 id="_permissive_mode" class="discrete">Permissive mode</h4>
<div class="paragraph">
<p>PartiQL can operate in a permissive mode or in a conventional type
checking mode, where the query fails once typing errors (such as the
above mentioned ones) happen. In the permissive mode, typing errors are
typically neglected by using the semantics outlined next.</p>
</div>
<div class="paragraph">
<p>In all of the above cases PartiQL returns the special value
<code>MISSING</code>. Recall, the <code>MISSING</code> is different from <code>NULL</code>. The
distinction enables PartiQL to be able to distinguish between a tuple
(JSON object) that lacked an attribute <code>a</code> and a tuple (JSON object)
whose <code>a</code> attribute was <code>NULL</code>. This distinction, coupled with
appropriate features on how result tuples are constructed (see
<code>SELECT</code> clause in <a href="#sec:select-values">Chapter 6</a>), enables PartiQL to easily
preserve (when needed) the distinction between absent attribute and
null-valued attribute.</p>
</div>
<div class="paragraph">
<p>For example, the expression ` 'not a tuple'.a ` and the expression
<code>{'a':1, 'b':2}</code> evaluate to <code>MISSING</code>.</p>
</div>
<div class="paragraph">
<p>The above semantics apply regardless of whether the tuple navigation
is accomplished via the dot notation or via the array notation. For
example, the expression <code>{'a':1, 'b':2}['noSuchAttribute']</code> will also
evaluate to <code>MISSING</code>.</p>
</div>
<h4 id="_type_checking_mode" class="discrete">Type checking mode</h4>
<div class="paragraph">
<p>In the type checking mode and in the absence of schema, PartiQL will
fail when tuple path navigation is applied on wrongly typed data.</p>
</div>
<div class="sect3">
<h4 id="sec:schema-in-tuple-path"><a class="anchor" href="#sec:schema-in-tuple-path"></a><a class="link" href="#sec:schema-in-tuple-path">4.1.1. Role of schema in type checking</a></h4>
<div class="paragraph">
<p>In the presence of schema, PartiQL may return a compile-time error when
the query processor can prove that the path expression is guaranteed to
<em>always</em> produce <code>MISSING</code>. The extent of error detection is
implementation-specific.</p>
</div>
<div class="paragraph">
<p>For example, in the presence of schema validation, an PartiQL query
processor can throw a compile-time error when given the path expression
<code>{a:1, b:2}.c</code>. In a more important and common case, an PartiQL implementation can
utilize the input data schema to prove that a path expression <em>always</em>
returns <code>MISSING</code> and thus throw a compile-time error. For example, assume that <code>sometable</code> is
an SQL table whose schema does not include an attribute <code>c</code>. Then, an
PartiQL implementation may throw a compile-time error when evaluating
the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT t.a, t.c FROM sometable AS t</code></pre>
</div>
</div>
<div class="paragraph">
<p>Apparently, such an PartiQL implementation is fully compatible with the
behavior of an SQL processor. Generally, if a rigid schema is explicitly
present, a tuple path navigation error can be caught during compilation
time; this is the case in SQL itself, where referring to a non-existent
attribute leads to a compilation error for the query.</p>
</div>
<div class="paragraph">
<p>Notice that operating with schema validation may not prevent all tuple
path navigations from being applied to wrongly typed data. The choice
between permissive mode versus type checking mode dictates what happens
next in these cases: If permissive, the tuple path navigation evaluates
into <code>MISSING</code>. If in type checking mode, the query fails.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:array-on-wrong"><a class="anchor" href="#sec:array-on-wrong"></a><a class="link" href="#sec:array-on-wrong">4.2. Array navigation evaluation on wrongly typed data</a></h3>
<div class="paragraph">
<p>In the permissive mode, an array navigation evaluation
\$a\[i]\$ will result into <code>MISSING</code> in each of the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$a\$ does not evaluate into an array, or</p>
</li>
<li>
<p>\$i\$ does not evaluate into a positive integer within the
array’s bounds.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, <code>[1,2,3][1.0]</code> evaluates to <code>MISSING</code> since <code>1.0</code> is not
an integer - even though it is coercible to an integer.</p>
</div>
<div class="paragraph">
<p>In type checking mode, the query will fail in each one of the cases
above.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:deep-navigation"><a class="anchor" href="#sec:deep-navigation"></a><a class="link" href="#sec:deep-navigation">4.3. Additional Path Syntax</a></h3>
<div class="paragraph">
<p>The following additional path functionalities are explained by reduction
to the basic tuple navigation and array navigation.</p>
</div>
<h4 id="_wildcard_steps" class="discrete">Wildcard steps</h4>
<div class="paragraph">
<p>The expression \$e\[**]\$ reduces to (i.e., is equivalent to):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v FROM e AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$v\$ is a <em>fresh variable</em>, i.e., a variable that does not
already appear in the query. Similarly, when the expression \$e.**\$
is not a <code>SELECT</code> clause item of the form \$t.*\$, where \$t\$ is a
variable, it reduces to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v FROM UNPIVOT e AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$v\$ is a fresh variable. An expression \$t.**\$, where
\$t\$ is a variable and the expression appears as a <code>SELECT</code> clause
item, is interpreted according to the <code>SELECT</code> clause semantics
(<a href="#sec:sql-star">Section 6.3.2</a>).</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>[1,2,3][*]</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v FROM [1, 2, 3] AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; 1,2,3 &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:1, &#39;b&#39;:2}.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v FROM UNPIVOT {&#39;a&#39;:1, &#39;b&#39;:2} AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;1,2&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whereas the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT t.* FROM &lt;&lt;{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2}&gt;&gt; AS t</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$-&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; {&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2} &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>does not do the transformation with <code>UNPIVOT</code>. If one does not want
this behavior, <code>SELECT VALUE</code> can be used (<a href="#sec:select-values">Chapter 6</a>).</p>
</div>
</div>
</div>
<h4 id="_path_expressions_with_wildcards" class="discrete">Path Expressions with Wildcards</h4>
<div class="paragraph">
<p>PartiQL also provides multi-step path expressions, called <em>path
collection expressions</em>. Their semantics is a generalization of the
semantics of a path expression with a single \$\[**]\$ or
\$.**\$. Consider the path collection expression:</p>
</div>
<div class="stemblock">
<div class="content">
\$e w_1 p_1...w_n p_n\$
</div>
</div>
<div class="paragraph">
<p>where \$e\$ is any expression; \$n&gt;0\$; each <em>wildcard step</em>
\$w_i\$ is either \$\[**]\$ or \$.**\$; each <em>series of
plain path steps</em> \$p_i\$ is a sequence of zero or more tuple path
navigations or array navigations (potentially mixed).</p>
</div>
<div class="paragraph">
<p>Then the path collection expression is equivalent to the SFW query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE vn.pn
FROM
    u1 e AS v1,
    u2 v1.p1 AS v1,
    . . .
    un @vn-1.pn-1 AS vn</code></pre>
</div>
</div>
<div class="paragraph">
<p>where each \$v_i\$ is a fresh variable and each \$u_i\$ is
<code>UNPIVOT</code> if \$w_i\$ is a \$.**\$ and it is nothing if
\$w_i\$ is a \$\[**]\$. Intuitively \$v_i\$ corresponds to
the \$i\$-th star.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. &#160;</div>
<div class="content">
<div class="paragraph">
<p>According to the above, consider the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE foo FROM e.* AS foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>reduces to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE foo FROM (SELECT VALUE v FROM UNPIVOT e AS v) AS foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE foo FROM UNPIVOT e AS foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, consider the path collection expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>tables.items[*].product.*.nest</code></pre>
</div>
</div>
<div class="paragraph">
<p>This expression reduces to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT
  VALUE v2.nest
FROM
  tables.items AS v1,
  UNPIVOT @v1.product AS v2</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:from"><a class="anchor" href="#sec:from"></a><a class="link" href="#sec:from">5. <code>FROM</code> Clause Semantics</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The formal semantics of a <code>FROM</code> clause describe the collection of
binding tuples \$B_"FROM"^"out"\$ that is output by the <code>FROM</code>
clause. The semantics specify three cases and essentially extend the
tuple calculus that underlies the SQL semantics.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The semantics specify what is the core semantics of a clause with a
single item (<a href="#sec:single-item-from">Section 5.1</a> and <a href="#sec:unpivot">Section 5.2</a>). The term
&#8220;semantics of the item \$f\$&#8221; is synonymous to the term
&#8220;semantics of a clause with the single item \$f\$&#8221;. In either
case, we refer to the specification of the collection of binding
tuples \$B^{out}_{\from}\$ that results from the evaluation of
&#8220;\$f\$&#8221;.</p>
</li>
<li>
<p>Then the semantics specify how multiple items combine, according to
the core semantics, using the join and outerjoin operations
(<a href="#sec:combining-multiple-item-join">Section 5.3</a>,
<a href="#sec:combining-multiple-item-leftjoin">Section 5.4</a> and
<a href="#sec:combining-multiple-item-full-outerjoin">Section 5.5</a>).</p>
</li>
<li>
<p>Finally, the semantics specify the syntactic sugar structures that are
overlaid over the core semantics. Their primary purpose is SQL
compatibility.</p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="sec:single-item-from"><a class="anchor" href="#sec:single-item-from"></a><a class="link" href="#sec:single-item-from">5.1. Ranging Over Bags and Arrays</a></h3>
<div class="paragraph">
<p>Next we define the semantics of a <code>FROM</code> clause that has a single
<code>FROM</code> item and such item ranges over a bag or array. First consider
the <code>FROM</code> clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM a AS v AT p</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us call \$v\$ to be the <em>element variable</em> and \$p\$ to be
the <em>position variable</em>. In the normal case, \$a\$ is an array
\$ \[ e_0, ..., e_{n-1} ] \$. The <code>FROM</code> clause outputs a bag of
binding tuples. For each \$e_i\$, the bag has a binding tuple
\$&lt; &lt; v: e_i, p:i &gt; &gt;\$.</p>
</div>
<div id="xmpl:single-from-item-with-order" class="exampleblock">
<div class="title">Example 5. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider the following \$p_0\$ (database environment):</p>
</div>
<div class="paragraph">
<p>\$ p_0 = &lt;&lt; \$<br>
\$ "someOrderedTable" : \[ \$<br>
\$ {'a':0, 'b':0}, \$<br>
\$ {'a':1, 'b':1} \$<br>
\$ ] \$<br>
\$ &gt;&gt; \$</p>
</div>
<div class="paragraph">
<p>then the following <code>FROM</code> clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM someOrderedTable AS x AT y</code></pre>
</div>
</div>
<div class="paragraph">
<p>outputs the bag of binding tuples:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" =\$ \$&lt; &lt;\$<br>
\$"    " &lt;&lt; x: {'a':0, 'b':0}, y:0 &gt;&gt; \$<br>
\$"    " &lt;&lt; x: {'a':1, 'b':1}, y:1 &gt;&gt; \$<br>
\$ &gt; &gt; \$</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As in SQL, the <code>AS</code> keyword is optional. The same applies to all cases below
where <code>AS</code> appears. If there is no <code>AT</code> clause, then the binding tuples have only
the element variable. In particular, consider:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM a AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally \$a\$ is a collection, i.e, an array \$
\[e_0,...,e_{n-1}] \$ or a bag \$ &lt; &lt; e_0,...,e_{n-1} &gt; &gt; \$. In
either case, the <code>FROM</code> clause outputs a bag. For each \$e_i\$, the bag
has a binding tuple \$ &lt;&lt; v:e_i &gt;&gt; \$.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again the database of <a href="#xmpl:single-from-item-with-order">Example 5</a>
and then the <code>FROM</code> clause</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM someOrderedTable AS x</code></pre>
</div>
</div>
<div class="paragraph">
<p>this clause outputs:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" =\$ \$&lt; &lt;\$<br>
\$"    " &lt;&lt; x: {'a':0, 'b':0} &gt;&gt; \$<br>
\$"    " &lt;&lt; x: {'a':1, 'b':1} &gt;&gt; \$<br>
\$ &gt; &gt; \$</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:bag-array-mistypings"><a class="anchor" href="#sec:bag-array-mistypings"></a><a class="link" href="#sec:bag-array-mistypings">5.1.1. Mistyping Cases</a></h4>
<div class="paragraph">
<p>In the following cases the expression in the <code>FROM</code> clause item has the wrong
type. Under the type checking option, all of these cases raise an error
and the query fails. Under the permissive option, the cases proceed as
follows</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Position variable on bags</dt>
<dd>
<p>Consider the clause:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM b AS v AT p</code></pre>
</div>
</div>
<div class="paragraph">
<p>and assume that \$b\$ is a bag \$&lt; &lt; e_0, ..., e_{n-1} &gt; &gt;
\$. The output is a bag with binding tuples \$&lt;&lt; v: e_i, p:
"MISSING" &gt;&gt;\$. The value <code>MISSING</code> for the variable \$p\$ indicates
that the order of elements in the bag was meaningless.</p>
</div>
</dd>
<dt class="hdlist1">Iteration over a scalar value</dt>
<dd>
<p>Consider the query:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM s AS v AT p</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM s AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$s\$ is a scalar value. Then \$s\$ coerces into the bag
\$&lt; &lt; s &gt; &gt;\$, i.e., the bag that has a single element, the
\$s\$. The rest of the semantics is identical to what happens when
the lhs of the <code>FROM</code> item is a bag.</p>
</div>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="title">Example 7. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again the database of <a href="#xmpl:single-from-item-with-order">Example 5</a>
and the <code>FROM</code> clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM someOrderedTable[0].a AS x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>someOrderedTable[0].a</code> evaluates to <code>0</code> and,
consequently, the <code>FROM</code> clause outputs a single binding tuple:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" =\$ \$&lt; &lt;\$ \$ &lt;&lt; x: 0 &gt;&gt; \$ \$ &gt; &gt; \$</p>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Iteration over a tuple value</dt>
<dd>
<p>Consider the query:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM t AS v AT p</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM t AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$t\$ is a tuple. Then \$t\$ coerces into the
bag \$&lt; &lt; t &gt; &gt;\$</p>
</div>
</dd>
<dt class="hdlist1">Iteration over an absent value</dt>
<dd>
<p>Consider the query</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM a AS v AT p</code></pre>
</div>
</div>
<div class="paragraph">
<p>or the query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM a AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas \$a\$ evaluates into an <em>absent value</em> (i.e., either
<code>MISSING</code> or <code>NULL</code>). In either case the <em>absent value</em> \$a\$
coerces into the bag \$&lt; &lt; a &gt; &gt;\$.  Then the semantics follow the
normal case.</p>
</div>
</dd>
</dl>
</div>
<div class="exampleblock">
<div class="title">Example 8. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again the database of <a href="#xmpl:single-from-item-with-order">Example 5</a>
and the clause</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM someOrderedTable[0].c AS x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression <code>someOrderedTable[0].c</code> evaluates to <code>MISSING</code> and,
consequently, the <code>FROM</code> clause outputs the binding tuple:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" =\$ \$&lt; &lt;\$ \$ &lt;&lt; x: "MISSING" &gt;&gt; \$ \$ &gt; &gt; \$</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:unpivot"><a class="anchor" href="#sec:unpivot"></a><a class="link" href="#sec:unpivot">5.2. Ranging over Attribute-Value Pairs</a></h3>
<div class="paragraph">
<p>The <code>UNPIVOT</code> clause enables ranging over the attribute-value pairs of a tuple.
The <code>FROM</code> clause</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM UNPIVOT t AS v AT a</code></pre>
</div>
</div>
<div class="paragraph">
<p>normally expects \$t\$ to be a tuple, with attribute/value pairs
\$ a_1:v_1, ..., a_n,v_n \$. It does not matter whether the tuple
is ordered or unordered. The <code>FROM</code> clause outputs the collection of binding
tuples</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" = &lt; &lt; &lt;&lt;v:v_1, a:a_1&gt;&gt; ... &lt;&lt;v:v_n, a:a_n&gt;&gt; &gt; &gt;\$</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider the \$p_0\$:</p>
</div>
<div class="paragraph">
<p>\$p_0 = &lt;&lt; "justATuple" : {'amzn': 840.05, 'tdc': 31.06} &gt;&gt;\$</p>
</div>
<div class="paragraph">
<p>The clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM UNPIVOT justATuple AS price AT symbol</code></pre>
</div>
</div>
<div class="paragraph">
<p>outputs:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" =\$ \$&lt; &lt;\$<br>
\$ &lt;&lt; price: 840.05, symbol: 'amzn' &gt;&gt; \$<br>
\$ &lt;&lt; price: 31.06, symbol: 'tdc' &gt;&gt; \$<br>
\$ &gt; &gt; \$</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:unpivot-mistypings"><a class="anchor" href="#sec:unpivot-mistypings"></a><a class="link" href="#sec:unpivot-mistypings">5.2.1. Mistyping Cases</a></h4>
<div class="paragraph">
<p>In the following cases the expression in the <code>FROM</code> <code>UNPIVOT</code> clause
item has the &#8220;wrong&#8221; type, i.e., it is not a tuple. Under the type
checking option, all of these cases raise an error and the query
fails. Under the permissive option, the cases proceed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM UNPIVOT x AS v AT n</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas \$x\$ is not a tuple and is not <code>MISSING</code>, is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM UNPIVOT {&#39;_1&#39;: x} AS v AT n</code></pre>
</div>
</div>
<div class="paragraph">
<p>Effectively, a tuple is generated for the non-tuple value. When
\$x\$ is <code>MISSING</code> then the above is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM UNPIVOT {} AS v AT n</code></pre>
</div>
</div>
<div class="paragraph">
<p>remember that a tuple cannot contain <code>MISSING</code>. So the present case is equivalent
to the empty tuple case.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:combining-multiple-item-join"><a class="anchor" href="#sec:combining-multiple-item-join"></a><a class="link" href="#sec:combining-multiple-item-join">5.3. Combining Multiple <code>FROM</code> Items with Comma, <code>CROSS JOIN</code> , or <code>JOIN</code></a></h3>
<div class="paragraph">
<p>The <code>FROM</code> clause expressions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l,r</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l CROSS JOIN r</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l JOIN r ON TRUE</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>have the same semantics. They combine the bag of bindings produced
from the <code>FROM</code> item \$l\$ with the bag of binding tuples produced
by the <code>FROM</code> item \$r\$, whereas the expression \$r\$ may
utilize variables defined by \$l\$. Again, the term “the semantics
of <code>l CROSSJOIN r</code>” is equivalent to the term “the semantics of
<code>FROM l CROSSJOIN r</code>”. In both cases, the semantics specify a bag of
binding tuples.</p>
</div>
<div class="sect3">
<h4 id="_associativity_of_cross_join"><a class="anchor" href="#_associativity_of_cross_join"></a><a class="link" href="#_associativity_of_cross_join">5.3.1. Associativity of <code>CROSS JOIN</code></a></h4>
<div class="paragraph">
<p>We explain the <code>CROSS JOIN</code> and <code>,</code> as if they are left associative
binary operators, despite the fact that one can write more than two
<code>FROM</code> items without specifying grouping with parenthesis. Since the
<code>,</code> and <code>CROSS JOIN</code> operators are associative, we may write (as is
common in SQL):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>f1, f2, f3</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>f1 CROSS JOIN f2 CROSS JOIN f3</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>f1 JOIN f2 ON TRUE JOIN f3 ON TRUE</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>(f1, f2), f3</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>(f1 CROSS JOIN f2) CROSS JOIN f3</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>(f1 JOIN f2 ON TRUE) JOIN f3 ON TRUE</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_semantics"><a class="anchor" href="#_semantics"></a><a class="link" href="#_semantics">5.3.2. Semantics</a></h4>
<div class="paragraph">
<p>Consider the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l CROSS JOIN r</code></pre>
</div>
</div>
<div class="paragraph">
<p>unlike SQL, the rhs \$r\$ of the expression may use variables
defined by the lhs item \$l\$. The result of this expression for a
database environment \$p_0\$ and variables environment \$p\$ is
the bag of binding tuples produced by the following pseudo-code. The
pseudo-code uses the function \$"eval"(p_0,p,e)\$ that evaluates
the expression \$e\$ within the environments \$p_0\$ and
\$p\$, i.e., \$p_0,p |-- e -&gt; "eval"(p_0,p,e)\$.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>for each binding tuple b_l in eval(p0,p,l)
    for each binding tuple b_r in eval(p0, (p || b_l), r)
    	add (b_l || b_r) to the output bag</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, the <code>l CROSS JION r</code> outputs all binding tuples
\$b = b^l || b^r\$, where \$b^l in "eval"(p_0,p,l)\$ and
\$b^r in "eval"(p_0, (p || b^l), r)\$. The key extension to SQL
is that \$r\$ is evaluated in the variables environment \$p ||
b^l\$, i.e., it can use the variables that were defined by
\$l\$. The details of the variable scoping aspects are described in
<a href="#sec:scoping-variables">Section 3.4</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. &#160;</div>
<div class="content">
<div class="paragraph">
<p>This example simply reminds the tuple calculus explanation of the <code>FROM</code> SQL
semantics. It does not yet endeavor into special aspects of PartiQL.
Consider the following database, which is conventional SQL:</p>
</div>
<div class="paragraph">
<p>\$ p_0 = &lt;&lt; \$<br>
\$    "customers": \[ \$<br>
\$        {"'id'": 5, "'name'": "'Joe'"}, \$<br>
\$        {"'id'": 7, "'name'": "'Mary'"} \$<br>
\$    ], \$<br>
\$    "orders": \[ \$<br>
\$        { "'custId'": 7, "'productId'" : 101}, \$<br>
\$        { "'custId'": 7, "'productId'" : 523} \$<br>
\$    ] \$<br>
\$ &gt;&gt; \$</p>
</div>
<div class="paragraph">
<p>Then consider the following <code>FROM</code> clause, which could be coming from a
conventional SQL query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM customers AS c, orders AS o</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in PartiQL this could also be written using the <code>CROSS JOIN</code>
keyword, and presumably, one would put the sensible equality condition
<code>c.id = o.custId</code> in the <code>WHERE</code> clause.  At any rate, this <code>FROM</code>
clause outputs the bag of binding tuples:</p>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" = &lt; &lt;\$<br>
\$ &lt;&lt; c: {"'id'": 5, "'name'": "'Joe'"}, o: {"'custId'": 7, "'productId'": 101} &gt;&gt; \$<br>
\$ &lt;&lt; c: {"'id'": 5, "'name'": "'Joe'"}, o: {"'custId'": 7, "'productId'": 523} &gt;&gt; \$<br>
\$ &lt;&lt; c: {"'id'": 7, "'name'": "'Mary'"}, o: {"'custId'": 7, "'productId'": 101} &gt;&gt; \$<br>
\$ &lt;&lt; c: {"'id'": 7, "'name'": "'Mary'"}, o: {"'custId'": 7, "'productId'": 523} &gt;&gt; \$<br>
\$&gt; &gt;\$</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Due to scoping rules that will be justified and elaborated in
<a href="#sec:variable-scoping">Chapter 10</a>, when the rhs of a <code>CROSS JOIN</code> is a path or
a function that uses a variable named \$n\$, such variable must be
referred as \$\@n\$.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider the database:</p>
</div>
<div class="paragraph">
<p>\$ p_0 = &lt;&lt; \$<br>
\$    "sensors": \[ \$<br>
\$        {"'readings'": [{"'v'": 1.3}, {"'v'": 2}\$}, ]<br>
\$        {"'readings'": [{"'v'": 0.7}, {"'v'": 0.8}, {"'v'": 0.9}\$} ]<br>
\$    ] \$<br>
\$ &gt;&gt; \$</p>
</div>
<div class="paragraph">
<p>Intuitively, the following <code>FROM</code> clause unnests the tuples that are nested
within the <code>readings</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM sensors AS s, s.readings AS r</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" = &lt; &lt;\$<br>
\$   s: {"'readings'": \[{"'v'": 1.3}, {"'v'": 2}]}, r: {v:1.3} \$<br>
\$   s: {"'readings'": \[{"'v'": 1.3}, {"'v'": 2}]}, r: {v:2} \$<br>
\$   s: {"'readings'": \[{"'v'": 0.7}, {"'v'": 0.8}, {"'v'": 0.9}]}, r: {"'v'":0.7} \$<br>
\$   s: {"'readings'": \[{"'v'": 0.7}, {"'v'": 0.8}, {"'v'": 0.9}]}, r: {"'v'":0.8} \$<br>
\$   s: {"'readings'": \[{"'v'": 0.7}, {"'v'": 0.8}, {"'v'": 0.9}]}, r: {"'v'":0.9} \$<br>
\$&gt; &gt;\$</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:combining-multiple-item-leftjoin"><a class="anchor" href="#sec:combining-multiple-item-leftjoin"></a><a class="link" href="#sec:combining-multiple-item-leftjoin">5.4. Combining Multiple Items with</a></h3>
<div class="paragraph">
<p>The <code>FROM</code> clause expression:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l LEFT CROSS JOIN r</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l LEFT JOIN r ON TRUE</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>replicates SQL’s <code>LEFT JOIN</code> functionality and, in addition, it also
works for the case where the lhs of \$r\$ uses variables defined
from \$l\$.</p>
</div>
<div class="paragraph">
<p>Let’s assume that the variables defined by \$r\$ are
\$v_1^r, ..., v_n^r\$. The result of evaluating <code>l LEFT CROSS JOIN r</code> in
environments \$p_0\$ and \$p\$ is the bag of binding tuples
produced by the following pseudocode, which also uses the
\$"eval"\$ function (See <a href="#sec:combining-multiple-item-join">Section 5.3</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>for each binding bl in eval(p0, p, l)
    Br = eval(p0,(p||bl),r)
    if Br is the empty bag
       add (bl || ⟨v1r : NULL . . . vnr : NULL⟩) to the output bag
    else
       for each binding br in Br
           add (bl || br) to the output bag</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 12. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider the database:</p>
</div>
<div class="paragraph">
<p>\$ p_0 = &lt;&lt; \$<br>
\$    "sensors": \[ \$<br>
\$        {"'readings'": \[{"'v'":1.3}, {"'v'":2}]} \$<br>
\$        {"'readings'": \[{"'v'":0.7}, {"'v'":0.8}, {"'v'":0.9}]}, \$<br>
\$        {"'readings'": \[]} \$<br>
\$      ] \$<br>
\$ &gt;&gt; \$</p>
</div>
<div class="paragraph">
<p>Notice that the value of the last tuple’s <code>reading</code> attribute is the
empty array.  The following <code>FROM</code> clause unnests the tuples that are
nested within the <code>readings</code> but will also keep around the tuple with
the empty <code>readings</code>. (See the last binding tuple.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM sensors AS s LEFT CROSS JOIN s.readings AS r</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$B_"FROM"^"out" = &lt; &lt;\$<br>
\$ s: {"'readings'": \[{"'v'":1.3}, {"'v'":2}]}, r: {"'v'":1.3} \$<br>
\$ s: {"'readings'": \[{"'v'":1.3}, {"'v'":2}]}, r: {"'v'":2} \$<br>
\$ s: {"'readings'": \[{"'v'":0.7}, {"'v'":0.8}, {"'v'":0.9}]}, r: {"'v'":0.7} \$<br>
\$ s: {"'readings'": \[{"'v'":0.7}, {"'v'":0.8}, {"'v'":0.9}]}, r: {"'v'":0.8} \$<br>
\$ s: {"'readings'": \[{"'v'":0.7}, {"'v'":0.8}, {"'v'":0.9}]}, r: {"'v'":0.9} \$<br>
\$ s: {"'readings'": \[]}, r: "NULL" \$<br>
\$ &gt;&gt; \$</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:combining-multiple-item-full-outerjoin"><a class="anchor" href="#sec:combining-multiple-item-full-outerjoin"></a><a class="link" href="#sec:combining-multiple-item-full-outerjoin">5.5. Combining Multiple <code>FROM</code> Items with <code>FULL JOIN</code></a></h3>
<div class="paragraph">
<p>The clause expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l FULL JOIN r ON c</code></pre>
</div>
</div>
<div class="paragraph">
<p>replicates SQL’s <code>FULL JOIN</code> functionality. It assumes that (alike
SQL) the lhs of \$r\$ does not use variables defined from
\$l\$. Thus, we do not discuss further.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:rewriting-on"><a class="anchor" href="#sec:rewriting-on"></a><a class="link" href="#sec:rewriting-on">5.6. Expanding <code>JOIN</code> and <code>LEFT JOIN</code> with <code>ON</code></a></h3>
<div class="paragraph">
<p>In compliance to SQL, the and have an optional clause. The semantics
of can be explained as syntactic sugar over the core PartiQL. They can
also be explained by a simple extension of the semantics of
<a href="#sec:combining-multiple-item-join">Section 5.3</a>,
<a href="#sec:combining-multiple-item-leftjoin">Section 5.4</a>, and
<a href="#sec:combining-multiple-item-full-outerjoin">Section 5.5</a>. The semantics of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l JOIN r ON c</code></pre>
</div>
</div>
<div class="paragraph">
<p>are the following modification of the pseudocode of
<a href="#sec:combining-multiple-item-join">Section 5.3</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>for each binding tuple b_l in eval(p0,p,l)
    for each binding tuple b_r in eval(p0, (p || b_l), r)
    	if eval(p0, (p || b_l || b_r), c) is true <i class="conum" data-value="1"></i><b>(1)</b>
	   add (b_l || b_r) to the output bag</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The modification for <code>ON</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The semantics of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>l LEFT JOIN r ON c</code></pre>
</div>
</div>
<div class="paragraph">
<p>are the following modification of the pseudocode of
<a href="#sec:combining-multiple-item-leftjoin">Section 5.4</a>. In essence, the outputs a
tuple padded with whenever there is no binding of \$r\$ that
satisfies the condition \$c\$.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code><span></span>for each binding bl in eval(p0, p, l)
    Br = eval(p0,(p||bl),r)
    Qr = &lt;&lt;&gt;&gt;
    for each binding br in Br
        if eval(p0, (p || bl || br), c) is true
	        add br in Qr
    if Qr is the empty bag
       add (bl || ⟨v1r : NULL . . . vnr : NULL⟩) to the output bag
    else
       for each binding br in Qr
           add (bl || br) to the output bag</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:lateral"><a class="anchor" href="#sec:lateral"></a><a class="link" href="#sec:lateral">5.7. SQL’s <code>LATERAL</code></a></h3>
<div class="paragraph">
<p>SQL 2003 used the <code>LATERAL</code> keyword to correlate clause items. In the
interest of compatibility with SQL, PartiQL also allows the use of the
keyword <code>LATERAL</code>, though it does not do anything more than the comma itself
would do. That is <code>l, LATERAL r</code> is equivalent <code>l, r</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:select-values"><a class="anchor" href="#sec:select-values"></a><a class="link" href="#sec:select-values">6. <code>SELECT</code> clauses</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Core PartiQL SFW queries have a <code>SELECT VALUE</code> clause (in lieu of
SQL’s <code>SELECT</code> clause) that can create outputs that are collections of
anything (e.g., collections of tuples, collections of scalars,
collections of arrays, collections of mixed type elements, etc.)
<a href="#sec:select-values-core">Section 6.1</a> describes the <code>SELECT VALUE</code> clause.</p>
</div>
<div class="paragraph">
<p>SQL’s well-known <code>SELECT</code> clause can be used as a mere syntactic sugar
over <code>SELECT VALUE</code>, when we consider the top-level query. In
particular, <a href="#sec:sql-select">Section 6.3</a> shows that SQL’s <code>SELECT</code> is the
special case where the <code>SELECT VALUE</code> produces collections of
tuples. Furthermore, when <code>SELECT</code> is used as a subquery it is coerced
into a scalar or a tuple, in the ways that SQL coerces the results of
subqueries.</p>
</div>
<div class="paragraph">
<p><a href="#sec:pivot_clause">Chapter 14</a> describes <code>PIVOT</code>, which can be used instead of <code>SELECT
VALUE</code>.  <code>PIVOT</code> creates a tuple, with a data dependent number of
attribute/value pairs, where not only the values but the attributes as
well could be originating from the data found in the binding tuples.</p>
</div>
<div class="sect2">
<h3 id="sec:select-values-core"><a class="anchor" href="#sec:select-values-core"></a><a class="link" href="#sec:select-values-core">6.1. <code>SELECT VALUE</code> core clause</a></h3>
<div class="paragraph">
<p>The <code>SELECT VALUE</code> clause inputs a bag of binding tuples or an array
of binding tuples (from the other clauses of the SQL query) and
outputs a bag or an array.  For example, if the query only has <code>SELECT
VALUE</code>, <code>FROM</code>, and <code>WHERE</code> clauses, then the bindings that are output
by the <code>WHERE</code> clause are input by <code>SELECT VALUE</code> the clause. Unlike
SQL, the output of a <code>SELECT VALUE</code> clause need not be a bag or array
of tuples. It is a bag or array of any kind of PartiQL values. For
example, it may be a bag of integers, or a bag of arrays, etc. Indeed,
the values may be heterogeneous. For example, the output may even be a
bag that has both integers and arrays.</p>
</div>
<div class="paragraph">
<p>The core PartiQL clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE e</code></pre>
</div>
</div>
<div class="paragraph">
<p>inputs a bag or an array (depending on the presence or non-presence of
<code>ORDER BY</code>) of binding tuples and outputs respectively a bag or an
array of values.  Let \$p_0\$ and \$p\$ be the environments of
the SFW query. For each input binding tuple \$b in
B_"SELECT"^"in"\$, outputs a value \$v\$, where \$p_0, (p ||
b) |-- e -&gt; v\$. Notice that PartiQL expressions \$e\$
(<a href="#figure:query:bnf">Listing 3</a> lines 17-30) will typically be tuple or array or
bag constructors (lines 20-22), which enable the construction of
respective results. In general \$e\$ can be any expression.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. &#160;</div>
<div class="content">
<div class="paragraph">
<p>This example illustrates a <code>SELECT VALUE</code> that creates a collection of numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE 2*x.a
FROM [{&#39;a&#39;:1}, {&#39;a&#39;:2}, {&#39;a&#39;:3}] as x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; 2, 4, 6 &gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:tuple-constructor"><a class="anchor" href="#sec:tuple-constructor"></a><a class="link" href="#sec:tuple-constructor">6.1.1. Tuple constructors</a></h4>
<div class="paragraph">
<p>A <em>tuple constructor</em> is of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{a1:e1, ..., an:en}</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas \$a_1...a_n, e_1...e_n\$ are expressions, potentially being
themselves constructors.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;a&#39;:v.a, &#39;b&#39;:v.b}
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2}] AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2}&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_treatment_of_mistyped_attribute_names"><a class="anchor" href="#_treatment_of_mistyped_attribute_names"></a><a class="link" href="#_treatment_of_mistyped_attribute_names">6.1.1.1. Treatment of mistyped attribute names</a></h5>
<div class="paragraph">
<p>It is possible that an expression \$a_i\$ that computes an
attribute name results into a non-string, i.e., a value that is not a
legitimate attribute name. In such cases, under the permissive mode
the attribute-value pair will be dismissed. Under the type checking
mode the query will fail.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. &#160;</div>
<div class="content">
<div class="paragraph">
<p>In the permissive mode, the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {v.a: v.b}
FROM [{&#39;a&#39;:&#39;legit&#39;, &#39;b&#39;:1}, {&#39;a&#39;:400, &#39;b&#39;:2}] AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;{&#39;legit&#39;:1}, {}&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the attempt to create an
attribute named <code>400</code> failed, thus leading to a tuple with no attributes.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_treatment_of_duplicate_attribute_names"><a class="anchor" href="#_treatment_of_duplicate_attribute_names"></a><a class="link" href="#_treatment_of_duplicate_attribute_names">6.1.1.2. Treatment of duplicate attribute names</a></h5>
<div class="paragraph">
<p>It is possible that the constructed tuples contain twice or more the
same attribute name.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {v.a: v.b,  v.c: v.d}
FROM [{&#39;a&#39;:&#39;same&#39;, &#39;b&#39;:1, &#39;c&#39;:&#39;same&#39;, &#39;d&#39;:2}] AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;{&#39;same&#39;:1, &#39;same&#39;:2}&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recall, a <code>same</code> path will only pick one of the two values.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:array-constructor"><a class="anchor" href="#sec:array-constructor"></a><a class="link" href="#sec:array-constructor">6.1.2. Array Constructors</a></h4>
<div class="paragraph">
<p>An array constructor has the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>[e1, ..., en]</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$e_1...e_n\$ are expressions. Notice that the arrays
produced by such constructor will always have size \$n+1\$.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE [v.a, v.b]
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2}] AS V</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;[1, 1], [2, 2]&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the interest of compatibility to SQL, PartiQL also allows array
constructors to be denoted with parentheses instead of brackets, when
there are at least two elements in the array, i.e., \$(n+1) &gt;= 2\$:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>(e1, ..., en)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#sec:select-coercion-array">Section 9.2</a> for uses of this feature in SQL
compatibility.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bag_constructors"><a class="anchor" href="#_bag_constructors"></a><a class="link" href="#_bag_constructors">6.1.3. Bag Constructors</a></h4>
<div class="paragraph">
<p>A bag constructor has the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;e1, ..., en&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$e_1..e_n\$ are expressions.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE &lt;&lt;v.a, v.b&gt;&gt;
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2, &#39;b&#39;:2}] AS v</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; &lt;&lt;1, 1&gt;&gt;, &lt;&lt;2, 2&gt;&gt; &gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:treatment-missing-select-value"><a class="anchor" href="#sec:treatment-missing-select-value"></a><a class="link" href="#sec:treatment-missing-select-value">6.1.4. Treatment of <code>MISSING</code> in <code>SELECT VALUE</code></a></h4>
<div class="paragraph">
<p><code>MISSING</code> may behave differently from <code>NULL</code> and differently from scalars. The following
itemizes the behavior of <code>MISSING</code> in a number of cases:</p>
</div>
<div class="sect4">
<h5 id="_when_constructing_tuples"><a class="anchor" href="#_when_constructing_tuples"></a><a class="link" href="#_when_constructing_tuples">6.1.4.1. When constructing tuples</a></h5>
<div class="paragraph">
<p>Whenever during tuple construction an attribute value evaluates to
<code>MISSING</code>, then the particular attribute/value is omitted from the
constructed tuple.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;a&#39;:v.a, &#39;b&#39;:v.b}
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_when_constructing_arrays"><a class="anchor" href="#_when_constructing_arrays"></a><a class="link" href="#_when_constructing_arrays">6.1.4.2. When constructing arrays</a></h5>
<div class="paragraph">
<p>Whenever an array element evaluates to <code>MISSING</code>, the resulting array
will contain a <code>MISSING</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE [v.a, v.b]
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;[1, 1], [2, MISSING]&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Upon output serialization the will convert to the symbol that the
serialization has chosen for serializing .</p>
</div>
</div>
<div class="sect4">
<h5 id="_when_constructing_bags"><a class="anchor" href="#_when_constructing_bags"></a><a class="link" href="#_when_constructing_bags">6.1.4.3. When constructing bags</a></h5>
<div class="paragraph">
<p>Whenever an element of a bag evaluates to <code>MISSING</code>, the resulting bag
will contain a corresponding <code>MISSING</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE v.b
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;1, MISSING&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>because <code>{'a':2}.b</code> evaluated to <code>MISSING</code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 22. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE &lt;&lt;v.a, v.b&gt;&gt;
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}]</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; &lt;&lt;1, 1&gt;&gt;, &lt;&lt;2, MISSING&gt;&gt; &gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:pivot"><a class="anchor" href="#sec:pivot"></a><a class="link" href="#sec:pivot">6.2. Pivoting a Collection into a Variable-Width Tuple</a></h3>
<div class="paragraph">
<p>The <code>PIVOT</code> clause may appear in lieu of <code>SELECT VALUE</code>. The <code>PIVOT</code> clause outputs a tuple; in
contrast, a <code>SELECT VALUE</code> outputs a collection (bag or array). The syntax is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>PIVOT e_v AT e_a
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the other clauses, <code>&#8230;&#8203;</code>, are the usual <code>FROM</code>,
<code>WHERE</code>, etc. The semantics are similar to <code>SELECT VALUE</code>. Let
\$p_0\$ and \$p\$ be the environments of the SFW query. For each
input binding tuple \$b in B_"PIVOT"^"in"\$ <code>PIVOT</code>, outputs an
attribute name/value pair \$a,v\$, where the name \$a\$ is the
result of \$e_a\$ and the value \$v\$ is the result of
\$e_v\$. (Technically, \$p_0, (p || b) |-- e_a |-&gt; a\$ and
\$p_0, (p || b) |-- e_v |-&gt; v\$.) Regardless of whether
\$B_"PIVOT"^"in"\$ is a bag (i.e., the SFW query did not have an )
or an array (i.e., the SFW query had an <code>ORDER BY</code>), the output tuple
is unordered. Schema may be applied extantly to obtain an ordered
tuple.</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>PIVOT t.price AT t.symbol
FROM [{&#39;symbol&#39;:&#39;tdc&#39;, &#39;price&#39;: 31.52}, {&#39;symbol&#39;: &#39;amzn&#39;, &#39;price&#39;: 840.05}] AS t</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into the tuple</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;tdc&#39;:31.52, &#39;amzn&#39;:840.05}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The treatment of <code>MISSING</code> is same to the treatment of <code>MISSING</code> by
<code>SELECT VALUE</code> (<a href="#sec:tuple-constructor">Section 6.1.1</a>). Namely, whenever an
attribute name or attribute value evaluates to <code>MISSING</code>, the
corresponding attribute name/value pair will not appear in the tuple.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 24. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>PIVOT t.price AT t.symbol
FROM [{&#39;symbol&#39;:25, &#39;price&#39;:31.52}, {&#39;symbol&#39;:&#39;amzn&#39;, &#39;price&#39;:840.05}] AS t</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into the tuple</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;amzn&#39;: 840.05}</code></pre>
</div>
</div>
<div class="paragraph">
<p>since <code>25</code> is not a legitimate attribute name.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:sql-select"><a class="anchor" href="#sec:sql-select"></a><a class="link" href="#sec:sql-select">6.3. SQL <code>SELECT</code> list as Syntactic Sugar of <code>SELECT VALUE</code></a></h3>
<div class="sect3">
<h4 id="sec:select-without-star"><a class="anchor" href="#sec:select-without-star"></a><a class="link" href="#sec:select-without-star">6.3.1. <code>SELECT</code> Without <code>*</code></a></h4>
<div class="paragraph">
<p>The SQL syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT e1 AS a1, ..., en AS an</code></pre>
</div>
</div>
<div class="paragraph">
<p>is syntactic sugar for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;a1&#39;:e1, ...., &#39;an&#39;:en}</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas if the attribute name \$a_i\$ is written as an identifier
(e.g., <code>a</code> or <code>"a"</code>) it is replaced by a single-quoted form
\$a_1'\$ (e.g., <code>'a'</code>).</p>
</div>
<div class="paragraph">
<p>When the expression \$e_i\$ is of the form \$e_i`.n\$ (i.e. a
path that navigates into tuple attribute \$n\$), PartiQL follows
SQL in allowing the attribute name to be optional. In this case,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...ei.n...</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...ei.n AS n...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case that the expression \$e_i\$ is not of the form
\$e_i`.n\$ the clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...ei...</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...e_i AS a_i...</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$a_i\$ is a system-generated name. SQL and PartiQL do not
provide a standard convention.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:sql-star"><a class="anchor" href="#sec:sql-star"></a><a class="link" href="#sec:sql-star">6.3.2. SQL’s <code>*</code></a></h4>
<div class="paragraph">
<p>Consider a query whose <code>FROM</code> defines a variable <code>x</code> that has no
schema and the <code>SELECT</code> clause includes at least one <code>x.*</code>. Let us
first consider the simpler case where the <code>SELECT</code> clause is a single
item <code>x</code>. Then the clause</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT x.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>reduces to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE CASE WHEN NOT x IS TUPLE THEN {&#39;_1&#39;: x} ELSE x END</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that PartiQL extends the <code>.*</code> to also operate on <code>x</code> bindings
that are not tuples. These are converted to singleton tuples with a
synthetic name.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT x.*
FROM [{&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}, &#39;foo&#39;] AS x</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; {&#39;a&#39;:1, &#39;b&#39;:1}, {&#39;a&#39;:2}, {&#39;_1&#39;:&#39;foo&#39;} &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the input has a non-tuple that was converted to a tuple
with a synthetic attribute name <code>_1</code>, this is because the result of a
traditional <code>SELECT</code> is always a container of tuples.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We generalize the semantics of a <code>SELECT</code> list, where at least one of
the items is a <code>.*</code> item, we use the function <code>TUPLEUNION</code>. When all
of \$t_1, t_2,...,t_n\$ are tuples \$"TUPLEUNION"(t_1,
t_2,...t_n)\$ outputs a tuple \$t\$ such that for each attribute
name/value pair \$n:v\$ of any \$t_i\$, the tuple \$t\$ has a
respective \$n:v\$. Notice the possibility that the output \$t\$
has duplicate attribute names because either (i) two different inputs
\$t_i\$ and \$t_j\$ had the same attribute name, or (ii) because
an input \$t_i\$ already had a duplicate attribute name.</p>
</div>
<div class="paragraph">
<p>Using <code>TUPLEUNION</code>, we rewrite the <code>SELECT</code> clause as illustrated by
the following example, which has two <code>.*</code> items and one conventional
item. The generalization to more items, of either kind should be
obvious. Notice that if \$v_1\$ (resp. \$v_3\$) is bound to a
non-tuple value \$v\$, then it is treated as if it were the tuple
\${"'_1'":v_1}\$ (resp. \${"'_2'":v_3}\$.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT v1.*, e2 AS a, v3.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE TUPLEUNION(
       CASE WHEN v1 IS TUPLE THEN v1 ELSE {&#39;_1&#39;: v1} END,
       {&#39;a&#39;:e2 },
       CASE WHEN v3 IS TUPLE THEN v3 ELSE {&#39;_2&#39;: v3} END
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the attribute names <code>'_1'</code>, <code>'_2'</code> have been invented.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_examples_with_combinations_of_multiple_features"><a class="anchor" href="#_examples_with_combinations_of_multiple_features"></a><a class="link" href="#_examples_with_combinations_of_multiple_features">6.4. Examples with combinations of multiple features</a></h3>
<div id="xmpl:nesting-readings" class="exampleblock">
<div class="title">Example 26. &#160;</div>
<div class="content">
<div class="paragraph">
<p>A SFW subquery may appear in the clause of a query, enabling the
creation of nested results.</p>
</div>
<div class="paragraph">
<p>Consider the database</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>  sensors :  [
         {&#39;sensor&#39;:1},
         {&#39;sensor&#39;:2}
  ]
  logs:  [
         {&#39;sensor&#39;:1, &#39;co&#39;:0.4},
         {&#39;sensor&#39;:1, &#39;co&#39;:0.2},
         {&#39;sensor&#39;:2, &#39;co&#39;:0.3}
  ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;sensor&#39;:  s.sensor,
              &#39;readings&#39;: (SELECT VALUE l.co
			   FROM logs AS l
			   WHERE l.sensor = s.sensor)
             }
FROM sensors AS s</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;
   {&#39;sensor&#39;:1, &#39;readings&#39;:&lt;&lt;0.4, 0.2&gt;&gt;},
   {&#39;sensor&#39;:2, &#39;readings&#39;:&lt;&lt;0.3&gt;&gt;}
&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that each tuple of the result has a nested array, which has been
created by the inner <code>SELECT VALUE</code>.</p>
</div>
<div class="paragraph">
<p>The query could also have been written using <code>SELECT</code> (instead of <code>SELECT VALUE</code>) for the outer
query, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT s.sensor AS sensor,
       ( SELECT VALUE l.co
         FROM logs AS l
         WHERE l.sensor = s.sensor) AS readings
FROM sensors AS s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, the <code>AS sensor</code> could be ommitted (as in SQL).</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 27. &#160;</div>
<div class="content">
<div class="paragraph">
<p>This example shows how the combined action of <code>UNPIVOT</code> and <code>PIVOT</code> enables to analyze the
attribute names. Consider the following database that has a sequence of
measurements of various gases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>sensors : [
    {&#39;no2&#39;:0.6, &#39;co&#39;:0.7, &#39;co2&#39;:0.5},
    {&#39;no2&#39;:0.5, &#39;co&#39;:0.4, &#39;co2&#39;:1.3}
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query keeps only the carbon oxides. <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE (PIVOT v AT g
              FROM UNPIVOT r AS v AT g
              WHERE g LIKE &#39;co%&#39;)
FROM sensors AS r</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>[
    {&#39;co&#39;:0.7, &#39;co2&#39;:0.5},
    {&#39;co&#39;:0.4, &#39;co2&#39;:1.3}
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Intuitively, the <code>UNPIVOT</code> turns every instance of the tuple <code>t</code> into
a collection.  The <code>WHERE</code> filters the collections. The <code>PIVOT</code> pivots
the filtered collections back into tuples.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:preds-and-fns"><a class="anchor" href="#sec:preds-and-fns"></a><a class="link" href="#sec:preds-and-fns">7. Functions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The semantics of predicates (i.e., functions returning booleans) and
(non-aggregate) functions in PartiQL are identical to those of SQL when
their inputs are those that are allowed by SQL. PartiQL makes the
following extensions for the cases where the inputs are beyond those
allowed by SQL.</p>
</div>
<div class="sect2">
<h3 id="sec:fns-with-wrong-inputs"><a class="anchor" href="#sec:fns-with-wrong-inputs"></a><a class="link" href="#sec:fns-with-wrong-inputs">7.1. Inputs with wrong types:</a></h3>
<div class="paragraph">
<p>Unlike SQL where typing issues can be detected during query compilation,
the permissive option of PartiQL has to define semantics for the case
where the inputs of a function are not compatible with the
function/predicate arguments. Furthermore, PartiQL facilitates
propagating missing input attributes to respective missing output
attributes.</p>
</div>
<div class="paragraph">
<p>Alike SQL, all functions have input argument types that they
conform to.  For example, the function <code>log</code> expects numbers. All
functions return <code>MISSING</code> when they input data whose types do not
conform to the input argument types.  Since no function (other than
<code>IS MISSING</code>) has <code>MISSING</code> as an input argument type, it follows that
all functions return <code>MISSING</code> when one of their inputs is <code>MISSING</code>.</p>
</div>
<div id="xmpl:missing-on-wrong-types" class="exampleblock">
<div class="title">Example 28. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;a&#39;:3*v.a, &#39;b&#39;:3*(CAST v.b AS INTEGER)}
FROM [ {&#39;a&#39;:1, &#39;b&#39;:&#39;1&#39;}, {&#39;a&#39;:2} ] v</code></pre>
</div>
</div>
<div class="paragraph">
<p>results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; {&#39;a&#39;:3, &#39;b&#39;:3}, {&#39;a&#39;:6 } &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the missing <code>b</code> attribute in the input leads to a
respective missing attribute in the output.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 29. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Each one of these expressions returns <code>MISSING</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>5 + MISSING</code></p>
</li>
<li>
<p><code>5 &gt; 'a'</code></p>
</li>
<li>
<p><code>NOT {a:1}</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:equality"><a class="anchor" href="#sec:equality"></a><a class="link" href="#sec:equality">7.1.1. Equality</a></h4>
<div class="paragraph">
<p>Equality never fails in the type-checking mode and never returns
<code>MISSING</code> in the permissive mode. Instead, it can compare values of
any two types, according to the rules of the PartiQL type system. For
example, <code>5 = 'a'</code> is <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Since PartiQL variables may bind to composite values (collections,
tuples), PartiQL extends the semantics of equality for these cases. In
particular, equality in PartiQL is <em>deep equality</em>, defined as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Given two arrays \$x\$ and \$y\$ that have the same length
\$l\$, the result of \$x=y\$ is the result of</p>
<div class="stemblock">
<div class="content">
\$"eqg"(x[0], y[0]) ^^ ... ^^ "eqg"(x[l], y[l])\$
</div>
</div>
<div class="paragraph">
<p>The <code>eqg</code>, unlike the <code>=</code>, returns true when a <code>NULL</code> is compared to a
<code>NULL</code> or a <code>MISSING</code> to a <code>MISSING</code>. When the arrays \$x\$ and
\$y\$ do not have the same length, the \$x=y\$ is <code>false</code>.</p>
</div>
</li>
<li>
<p>A similar straightforward equality applies to tuples: They have to
have the same attributes. Then equality \$t_1 = t_2\$ is true if</p>
<div class="stemblock">
<div class="content">
\$"eqg"(t_1.a_1, t_2.a_1) ^^ ... ^^ "eqg"(t_1.a_n, t_2.a_n)\$
</div>
</div>
<div class="paragraph">
<p>where \$a_1, ..., a_n\$ are the attributes that appear in
\$t_1\$ and \$t_2\$.</p>
</div>
</li>
<li>
<p>Equality for bags is similarly straightforward: Two bags \$x\$
and \$y\$ are equal if and only if every element \$e\$ of
\$x\$ that appears \$n\$ times in \$x\$ also appears \$n\$
times in \$y\$.</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="title">Example 30. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The following are true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;3, 2, 4, 2 &gt;&gt; = &lt;&lt;2, 2, 3, 4 &gt;&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:1, &#39;b&#39;:2} = {&#39;b&#39;:2, &#39;a&#39;:1}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:[0,1], &#39;b&#39;:2} = {&#39;b&#39;:2, &#39;a&#39;:[0,1]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are false:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;3, 4, 2 &gt;&gt; = &lt;&lt;2, 2, 3, 4 &gt;&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:1, &#39;b&#39;:2} = {&#39;a&#39;:1}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:[0,1], &#39;b&#39;:2} = {&#39;b&#39;:2, &#39;a&#39;:[0,1,2]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are also false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:1, &#39;b&#39;:2} = {&#39;a&#39;:1}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:1, &#39;b&#39;:2} = {&#39;a&#39;:1, &#39;b&#39;:null}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;a&#39;:[0,1], &#39;b&#39;:2} = {&#39;b&#39;:2, &#39;a&#39;:[null,1]}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:where"><a class="anchor" href="#sec:where"></a><a class="link" href="#sec:where">8. <code>WHERE</code> clause</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>WHERE</code> clause inputs the bindings that have been produced from
the <code>FROM</code> clause and outputs the ones that satisfy its condition.</p>
</div>
<div class="paragraph">
<p>The boolean predicates follow SQL’s 3-valued logic. Recall, PartiQL
has two kinds of absent values: <code>NULL</code> and <code>MISSING</code>. As far as the
boolean connectives and <code>IS NULL</code> are concerned a <code>NULL</code> input and a
<code>MISSING</code> input behave identically. For example, <code>MISSING AND TRUE</code> is
equivalent to <code>NULL AND TRUE</code>: they both result into <code>NULL</code>.</p>
</div>
<div class="paragraph">
<p>For the semantics of equality and of other functions, see
<a href="#sec:preds-and-fns">Chapter 7</a>.</p>
</div>
<div class="paragraph">
<p>Alike SQL, when the expression of the <code>WHERE</code> clause expression
evaluates to an absent value or a value that is not a Boolean, PartiQL
eliminates the corresponding binding.</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The result of</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUES v.a
FROM [{&#39;a&#39;:1, &#39;b&#39;:true}, {&#39;a&#39;:2, &#39;b&#39;:null}, {&#39;a&#39;:3}] v
WHERE v.b</code></pre>
</div>
</div>
<div class="paragraph">
<p>is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; 1 &gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The predicate <code>IS MISSING</code> allows distinguishing between <code>NULL</code> and
<code>MISSING</code>: <code>NULL IS MISSING</code> results to false; <code>MISSING IS MISSING</code>
results to true.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:subquery-coercion"><a class="anchor" href="#sec:subquery-coercion"></a><a class="link" href="#sec:subquery-coercion">9. Coercion of subqueries</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In PartiQL, as is the case with SQL as well, expressions may involve
SFW subqueries (<a href="#figure:query:bnf">Listing 3</a> line 17). PartiQL SFW subqueries
are enclosed in parentheses (i.e., identical to SQL). For
compatibility with SQL, a SFW subquery starting with a <code>SELECT</code> clause
(as opposed to a subquery starting with <code>SELECT VALUE</code> or <code>PIVOT</code>)
coerces into a scalar or into an array, depending on the context. The
following cases replicate SQL’s coercing behavior and analyze in which
cases the result of a subquery coerces into scalar and in which cases
they coerce into arrays.</p>
</div>
<div class="paragraph">
<p>An PartiQL extension with respect to SQL is that, in the permissive
mode, subqueries that fail to coerce to the required type (scalar or
tuple) still run, as opposed to failing. They simply omit from the
results the data that correspond to the coercion failures.</p>
</div>
<div class="sect2">
<h3 id="sec:select-coercion-scalar"><a class="anchor" href="#sec:select-coercion-scalar"></a><a class="link" href="#sec:select-coercion-scalar">9.1. Coercion of a <code>SELECT</code> subquery into a scalar</a></h3>
<div class="paragraph">
<p>In each of the following cases a SFW subquery coerces into a scalar</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if it appears as the rhs of a comparison operator (<code>=</code>, <code>&gt;</code>, etc)
where the lhs is not an array literal. And, vice versa, if it appears
as the lhs of a comparison operator where the rhs is not an array
literal. (If it is the lhs of a comparison operator where the lhs is
an array literal, it coerces into array, per
<a href="#sec:select-coercion-array">Section 9.2</a>.)</p>
</li>
<li>
<p>if it is an SFW subquery expression that (a) is not the collection
expression of a <code>FROM</code> clause item and (b) is not the rhs of an
<code>IN</code>. (If it is the rhs of an <code>IN</code> then it should not be coerced.)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essentially, a subquery that is coerced may appear in all clauses
except the <code>FROM</code>. For example, it may be a <code>SELECT</code> subquery \$s\$
that appears as an item of a <code>SELECT</code>, <code>SELECT VALUE</code>, or <code>PIVOT</code>
clause. Or it may be a subexpression of an expression that appears in
<code>SELECT</code>, <code>SELECT VALUE</code> , or <code>PIVOT</code> clause. Or it may be a
subexpression of the <code>WHERE</code> clause expression, as long as it is not
the rhs of an <code>IN</code>. In any of these cases the result of the subquery
\$s\$ is cast into a scalar.</p>
</div>
<div class="paragraph">
<p>Technically, the subquery \$s\$ (which uses <code>SELECT</code>) is rewritten
into an equivalent subquery \$s'\$ that utilizes <code>SELECT VALUE</code>, by
following the steps of <a href="#sec:sql-select">Section 6.3</a>. Then the result of
\$s'\$ is cast into a scalar by applying the function
\$"COLL_TO_SCALAR"(s')\$.</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The SQL query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT v.foo,
       (SELECT w.bar
        FROM someDataSet w
        WHERE w.sth = v.sthelse) AS bar
FROM anotherDataSet v</code></pre>
</div>
</div>
<div class="paragraph">
<p>is rewritten into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {
    &#39;foo&#39;:  v.foo
    &#39;bar&#39;:  COLL_TO_SCALAR(SELECT VALUE {&#39;bar&#39;:  w.bar}
                           FROM someDataSet w
                           WHERE w.sth = v.sthelse)
}
FROM anotherDataSet v</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As is the common semantics of PartiQL in the permissive mode, when
<code>COLL_TO_SCALAR</code> fails to cast the subquery into a scalar, it outputs
<code>MISSING</code>. The inputs that are coerced into scalars are the ones that
SQL prescribes: When the input is a collection consisting of a single
tuple with a single attribute, the input is coerced into a scalar. All
other inputs to <code>COLL_TO_SCALAR</code> lead to <code>MISSING</code>.</p>
</div>
<div id="xmpl:coercion-failure" class="exampleblock">
<div class="title">Example 33. &#160;</div>
<div class="content">
<div class="paragraph">
<p>In this example, in one instance the inner <code>SELECT</code> evaluates to a
collection with more than one element. Because the <code>COLL_TO_SCALAR</code>
function produces a <code>MISSING</code> instead of failing, the query works.</p>
</div>
<div class="paragraph">
<p>Consider the tables</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>customers :  [
    {&#39;id&#39;:1, &#39;name&#39;:&#39;Mary&#39;},
    {&#39;id&#39;:2, &#39;name&#39;:&#39;Helen&#39;},
    {&#39;id&#39;:1, &#39;name&#39;:&#39;John&#39;}
]
orders :  [
    {&#39;custId&#39;:1, &#39;name&#39;:&#39;foo&#39;},
    {&#39;custId&#39;:2, &#39;name&#39;:&#39;bar&#39;}
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following query would fail in SQL, because there are two customer
tuples with the same id. Of course, in a well-designed SQL database that
has a primary key or uniqueness constraint on the id, there would not be
two customers with the same id. However, lack of constraints is typical
in the data targeted by PartiQL. This query runs in the permissive mode
of PartiQL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT o.name AS orderName,
       (SELECT c.name FROM customers c WHERE c.id=o.custId) AS customerName
FROM orders o</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; {&#39;orderName&#39;:&#39;foo&#39;}, {&#39;orderName&#39;:&#39;bar&#39;, &#39;customerName&#39;:&#39;Helen&#39;} &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the missing <code>'customerName'</code> in the first tuple.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As in SQL, an implementation with static type checks will be able to
detect and warn that, in certain cases, a coercion will always fail and
produce <code>MISSING</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The following <code>SELECT</code> clause is guaranteed to produce tuples with
<code>bar</code> and <code>bar2</code>. Thus it cannot coerce into scalar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT w.bar1 AS bar1, w.bar2 AS bar2
FROM someDataSet w</code></pre>
</div>
</div>
<div class="paragraph">
<p>Static type analysis can infer that the nested query above will
deliver tuples consisting of <code>bar</code> and <code>bar2</code>. Thus, even before
accessing any data, it can warn the user that this query is erroneous.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:select-coercion-array"><a class="anchor" href="#sec:select-coercion-array"></a><a class="link" href="#sec:select-coercion-array">9.2. Coercion of a <code>SELECT</code> subquery into an array</a></h3>
<div class="paragraph">
<p>An <code>SELECT</code> SFW subquery coerces into an array when it is the rhs
(respectively, lhs) of a comparison operator whose other argument is
an array. <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup></p>
</div>
<div class="paragraph">
<p>The reduction of a <code>SELECT</code> subquery to the PartiQL is exhibited by the following
example.</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The SQL query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT v.foo
FROM anotherDataSet v
WHERE (v.a, v.b) = (SELECT w.c, w,d
                    FROM someDataSet w
                    WHERE w.sth = v.sthelse)</code></pre>
</div>
</div>
<div class="paragraph">
<p>is rewritten into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;foo&#39;:  v.foo}
FROM anotherDataSet v
WHERE (v.a, v.b) = (SELECT VALUE [w.c, w,d]
                    FROM someDataSet w
                    WHERE w.sth = v.sthelse)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:variable-scoping"><a class="anchor" href="#sec:variable-scoping"></a><a class="link" href="#sec:variable-scoping">10. Scoping rules</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>As far as the variables environment is concerned, the scoping rules
are identical to those of SQL. <a href="#sec:scoping-variables">Section 3.4</a> explained
how the resolution of variable naming conflicts favors the variables
defined by the inner queries.</p>
</div>
<div class="paragraph">
<p>The scoping rules discussed in the present section discuss the
resolution of naming conflicts between names defined in the database
environment and the variables of the environment variables. The
potential for such naming conflicts is driven by the nested data of
PartiQL, as illustrated next.</p>
</div>
<div class="paragraph">
<p>Notice there are a few more naming conventions, pertaining to the use
of attribute names defined in <code>the</code> SELECT clause into the <code>GROUP BY</code>
and <code>ORDER BY</code> clause. These conventions are explained in along with
the semantics of the respective clauses (see <a href="#section:groupby">Chapter 11</a> and
<a href="#section:order-by">Chapter 12</a>).</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The following example illustrates how SQL compatibility issues and the
needs of navigating into nested data need to be carefully merged
together. Consider the following database that has a table <code>c</code>, i.e. a
collection of tuples, and also named data <code>x.n</code> and <code>y</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>t.c: &lt;&lt;
    {&#39;a&#39;:1, &#39;n&#39;:[{&#39;b&#39;:11, &#39;c&#39;:12}]},
    {&#39;a&#39;:2, &#39;n&#39;:[{&#39;b&#39;:21, &#39;c&#39;:22}]}
&gt;&gt;
x.n : &lt;&lt; {&#39;b&#39;:3} &gt;&gt;
y: {&#39;a&#39;:1, &#39;b&#39;:2}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then consider the query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT t.a
FROM t.c AS x
WHERE x.a IN (SELECT y.b FROM x.n AS y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query poses many scoping issues:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Does <code>x.n</code> refer to the named value <code>x.n</code> or to the <code>n</code> attribute of
the variable <code>x</code>?  For SQL compatibility purposes it refers to the
named value <code>x.n</code>. Read below how to refer to the variable <code>x</code>.</p>
</li>
<li>
<p>Does <code>y.b</code> refer to the <code>b</code> attribute of the <code>y</code> attribute or to the
<code>b</code> attribute of the named value <code>y</code>? For SQL compatibility purposes it
refers to the <code>b</code> attribute of the variable <code>y</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Notice how SQL compatibility required the database environment to take
priority over the variables environment in the <code>FROM</code> clause and then, vice
versa, the variables environment to take priority over the database
environment in the <code>SELECT</code> clause.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scoping_rules_resolving_naming_conflicts_between_variables_and"><a class="anchor" href="#_scoping_rules_resolving_naming_conflicts_between_variables_and"></a><a class="link" href="#_scoping_rules_resolving_naming_conflicts_between_variables_and">10.1. Scoping rules resolving naming conflicts between variables and</a></h3>
<div class="paragraph">
<p>database names Since the rules are easier to express when all database
names are a single identifier, such as <code>thedb</code> or <code>"the db"</code> (as
opposed to paths, such as <code>somedb.sometable</code>), we first specify the
scoping rules under the assumption that all database names are a
single identifier. We remove the assumption and generalize later.</p>
</div>
<div class="paragraph">
<p>In the absence of schema the following rules apply</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>@identifier</code> refers to the environment variable named <code>identifier</code>;
if there is no such environment variable, the <code>identifier</code> refers to
the database name <code>identifier</code>; if there is no such database name
either, the query fails compilation.</p>
</li>
<li>
<p>in a <code>FROM</code> clause path that starts with <code>identifier</code>, the <code>identifier</code> refers to
the database name <code>identifier</code>; if there is no such database name, the refers to a
variable; otherwise query fails compilation. <sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup></p>
</li>
<li>
<p>in a non-<code>FROM</code> clause path that starts with <code>identifier</code>, the
<code>identifier</code> refers to the environment variable named <code>identifier</code>; if
there is no such environment variable, the <code>identifier</code> refers to the
database name <code>identifier</code>; if there is no such database name either,
the query fails compilation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, we generalize to also allow for the possibility of database
names of the form <code>identifier.identifier. &#8230;&#8203;</code>. The following rules
apply regarding the semantics of \$i_1.i_2. ... .i_n\$, where
\$i_1, i_2, ..., i_n\$ are identifiers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$\@i_1.i_2. ... .i_n\$ always refers to the environment variable
named \$i_1\$; if there is no such variable and
\$i_1.i_2. ... .i_m, m &lt;= n\$ is a database name then
\$i_1.i_2. ... .i_m\$ refers to such named database name. Again, if
there is a choice, choose the largest \$m\$. If both the resolution
to variable and the resolution to database name, fail the query during
compilation.</p>
</li>
<li>
<p>if \$i_1.i_2. ... .i_n\$ is a <code>FROM</code> path and
\$i_1.i_2. ... .i_m, m &lt;= n\$ is a database name then
\$i_1.i_2. ... .i_m\$ refers to such named database name and
\$i_{m+1}. ... .i_n\$ is a series of tuple path navigations
starting from the database name \$i_1.i_2. ... .i_m\$.  If there is
a choice, choose the largest \$m\$, i.e., the longest database
name.</p>
</li>
<li>
<p>if \$i_1.i_2. ... .i_n\$ is a non-<code>FROM</code> clause expression and
\$i_1\$ is an environment variable then \$i_1\$ refers to such
variable; if there is no such variable and \$i_1.i_2. ... .i_m, m
&lt;= n\$ is a database name then \$i_1.i_2. ... .i_m\$ refers to such
named database name. Again, if there is a choice, choose the largest
\$m\$. If both the resolution to variable and the resolution to
database name, fail the query during compilation.</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 37. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Assume database names <code>coll</code>, <code>v.foo</code>, <code>w</code>. Then in the query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><div class="lineno"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span>SELECT v.foo
FROM coll AS v, @v.foo AS w,
     (SELECT w.a, u.b FROM @w.bar AS u)
         AS x
</pre></div></td></tr></table></div></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>coll</code> refers to the database name. The <code>v</code> in <code>@v.foo</code> refers to the
variable <code>v</code>. If the <code>@</code> were not there, <code>v.foo</code> would refer to the database
name <code>v.foo</code>. The <code>w</code> in <code>w.a</code> refers to the variable defined in line 2.</p>
</div>
<div class="paragraph">
<p>Note, the expressions <code>coll</code> and <code>@v.foo</code> are <code>FROM</code> clause
expressions because they appear in the <code>FROM</code> clause of the
<em>sfw_query</em> of lines 1-4, in which they are immediately nested.
Similarly, the expression <code>@w.bar</code> is a <code>FROM</code> clause expression
because it appears in the <code>FROM</code> clause of the <em>sfw_query</em> of line 3,
in which it is immediately nested. In contrast, the expressions <code>w.a</code>
and <code>u.b</code> are not <code>FROM</code> clause expressions. Though they are nested
into the <code>FROM</code> clause of the query of lines 1-4, they are not
immediately nested into the query of lines 1-4.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section:groupby"><a class="anchor" href="#section:groupby"></a><a class="link" href="#section:groupby">11. <code>GROUP BY</code> clause</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The PartiQL <code>GROUP BY</code> clause expands SQL&#8217;s grouping. Unlike SQL, the
PartiQL <code>GROUP BY</code> can be thought of as a standalone operator that
inputs a collection of binding tuples and outputs a collection of
binding tuples.</p>
</div>
<div class="paragraph">
<p>As is typical in many clauses, the semantics proceed in two steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#sec:group-variable">Section 11.1</a> explains the core PartiQL <code>GROUP BY</code>
structure.</p>
</li>
<li>
<p><a href="#sec:sql-groupby">Section 11.2</a> shows that SQL&#8217;s can be explained over the core
<code>GROUP BY</code>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="sec:group-variable"><a class="anchor" href="#sec:group-variable"></a><a class="link" href="#sec:group-variable">11.1. PartiQL <code>GROUP BY</code> core: Grouping into a Group Variable</a></h3>
<div class="paragraph">
<p>The <code>GROUP BY</code> clause (<a href="#figure:query:bnf">Listing 3</a> lines 7-9)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>GROUP BY e1 AS x1, ..., em AS xm GROUP AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>creates a group. Each \$e_i\$ is a <em>grouping expression</em>, each
\$x_i\$ is a <em>grouping variable</em> <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup> and \$g\$ is the
<em>group variable</em>.</p>
</div>
<div class="paragraph">
<p>As in SQL, the bag of input binding tuples \$B_"GROUP"^"in"\$ is
partitioned into the minimal number of equivalence groups
\$B_1,...,B_n\$, such that any two binding tuples \$b, b' in
B_"GROUP"^"in"\$ are in the same equivalence group if and only if every
grouping expression \$e_i\$ evaluates to equivalent values
\$v_i\$ (when evaluated on \$b\$) and \$ v_i' \$ (when
evaluated on \$b'\$). More precisely, as in SQL, there is an
equivalence function \$"eqg"\$, used by the <code>GROUP BY</code> to determine
if two values \$v_i\$ and \$ v_i' \$ are equivalent for grouping
purposes. The equivalence function \$"eqg"(v_i, v_i' )\$ returns
only true or false; true meaning that the values are equivalent for
grouping purposes. See <a href="#sec:eqg">Section 11.1.1</a> for specifics of <code>eqg</code>. If a
grouping expression evaluates to <code>MISSING</code>, it is first coerced into
<code>NULL</code>, thus bringing <code>MISSING</code> and <code>NULL</code> in the same group.</p>
</div>
<div class="paragraph">
<p>Unlike SQL, for each group \$B_j (1 &lt;= j &lt;= n)\$, the <code>GROUP BY</code>
clause outputs a binding tuple \$b_j = (: x_1 : v_1,...,x_m : v_m,
g : B_j:)\$ that has the full group \$B_j\$. Notice:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the binding tuples that appear in the \$g\$ collection have
one attribute for each of the variables defined in the <code>FROM</code> clause, since
these binding tuples come as-is from \$B_"GROUP"^"in"\$.</p>
</li>
<li>
<p>even if the bag \$B_"GROUP"^"in"\$ is flat binding tuples, the
output bag \$B_"GROUP"^"out"\$ is not just flat binding tuples,
since \$g\$ has nested binding tuples.  Note, we have been
explicitly denoting binding attributes with <code>MISSING</code> values in the
binding tuples. However, once these binding tuples become the tuples
of the PartiQL data model, any binding attribute with <code>MISSING</code> value
will not appear.</p>
</li>
</ol>
</div>
<div id="sec:grouping-readings" class="exampleblock">
<div class="title">Example 38. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again <code>logs</code> the data of <a href="#xmpl:nesting-readings">Example 26</a> and assume
that we want to group the <code>co</code> readings by sensor. The following query
solves the problem using only core features.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;sensor&#39;: sensor,
              &#39;readings&#39;: (SELECT VALUE v.l.co FROM g AS v) }
FROM logs AS l
GROUP BY l.sensor AS sensor GROUP AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>GROUP BY</code> outputs the collection of binding tuples</p>
</div>
<div class="paragraph">
<p>\$ B_"GROUP"^"out" = B_"SELECT"^"in" = \$ \$&lt; &lt;\$<br>
\$ (: "sensor":1, g: &lt; &lt; (: l:{"'sensor'":1, "'co'":0.4} :)  (: l:{"'sensor'":1, "'co'":0.2} :) &gt; &gt; :) \$<br>
\$ (: "sensor":2, g: &lt; &lt; (: l:{"'sensor'":2, "'co'":0.3} :) &gt; &gt; :) \$<br>
\$ &gt; &gt; \$</p>
</div>
<div class="paragraph">
<p>Notice that the collection \$g\$ has tuples with a single attribute \$l\$, since
this is the single variable of the <code>FROM</code> clause in this example.</p>
</div>
<div class="paragraph">
<p>Consequently the <code>SELECT</code> clause outputs</p>
</div>
<div class="paragraph">
<p>\$ &lt; &lt; \$<br>
\$   {"'sensor'":1, "'readings'": &lt; &lt; 0.4, 0.2 &gt; &gt; }, \$<br>
\$   {"'sensor'":2, "'readings'": &lt; &lt; 0.3 &gt; &gt; } \$<br>
\$ &gt; &gt; \$<br></p>
</div>
<div class="paragraph">
<p>Notice that the query of <a href="#xmpl:nesting-readings">Example 26</a> and the query of
the present example do not always produce the same result. For
example, if there were no readings for a sensor, the query of
<a href="#xmpl:nesting-readings">Example 26</a> would still have this sensor in the result
(and its <code>readings</code> would be empty). In contrast, the query of the
present example will not have this sensor in the result.</p>
</div>
<div class="paragraph">
<p>Here is a shorter equivalent query that uses PartiQL collection paths
and SQL&#8217;s aliases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;sensor&#39;: sensor,
              &#39;readings&#39;: g[*].l.co }
FROM logs AS l
GROUP BY l.sensor AS sensor GROUP AS g</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice, the output binding tuple provides the partitioned input
binding tuples in the group variable \$g\$, which can be explicitly
utilized in subsequent <code>HAVING</code>, <code>ORDER BY</code>, and <code>SELECT</code>
clauses. Thus, an PartiQL query can perform complex computations on
the groups, leading to results of any type (e.g.  collections nested
within collections). The explicit presence of groups in PartiQL, while
more general than SQL, also leads to simpler semantics than those of
SQL, since the <code>GROUP BY</code> clause semantics are independent of the presence of
subsequent functions in <code>HAVING</code>, <code>ORDER BY</code>, and <code>SELECT</code>.</p>
</div>
<div id="xmpl:groupby-avg-count" class="exampleblock">
<div class="title">Example 39. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The following PartiQL query counts and averages the readings of each
sensor. It also refers to the <code>logs</code> of <a href="#xmpl:nesting-readings">Example 26</a>. The
<code>COLL_COUNT</code> function is simply given the group variable and counts
how many elements are in that collection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;sensor&#39;: sensor,
              &#39;avg&#39;: COLL_AVG(SELECT VALUE v.l.co FROM g AS v),
              &#39;count&#39;: COLL_COUNT(g) }
GROUP BY l.sensor AS sensor GROUP AS g</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice, the aggregate functions <code>COLL_AVG</code> and <code>COLL_COUNT</code> (and for
that matter, by convention, any function starting with <code>COLL</code>) can be
thought of as general-purpose functions. Generally, they do not have
to be fed by the result of a grouping operation - unlike SQL&#8217;s <code>COUNT</code>
and <code>AVG</code> that are being fed exclusively from the results of grouping
operations. (Furthermore, the SQL <code>COUNT</code> and <code>AVG</code> make use of SQL&#8217;s
syntactic sugar, where there is no explicit use of group variable, as
explained in <a href="#sec:implicit-group-variable">Section 11.2.2</a>.)</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. &#160;</div>
<div class="content">
<div class="paragraph">
<p>This is a legitimate PartiQL expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>COLL_COUNT([5, {a:2, b:3}])</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is <code>2</code>, since the input to <code>COLL_COUNT</code> is an array with
two elements.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Similarly, it is fine to include in any clause an aggregate function fed
by the result of a (sub)query.</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. &#160;</div>
<div class="content">
<div class="paragraph">
<p>In the following expression <code>COLL_COUNT</code> inputs the result of a query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>COLL_COUNT(SELECT VALUE x FROM logs x WHERE x.sensor=1)</code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An efficient implementation will often avoid materializing the group
variable. In many cases, like the ones of the above examples, the group
can be streamed into the aggregate function.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The semantics of the <code>SELECT</code> and <code>HAVING</code> clauses do not need to be
aware of the presence of <code>GROUP BY</code> and treat differently (as SQL
would do) these classes of functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>scalar functions (e.g. <code>+</code>) that input scalars and output scalars</p>
</li>
<li>
<p>SQL aggregation functions (e.g. <code>SUM</code>) that input bags and output scalars</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Indeed, <code>HAVING</code> behaves identical to a <code>WHERE</code>, once groups are
already formulated earlier.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The PartiQL approach provides two benefits: First, it leads to
shorter, modular semantics. Second, it enables <code>GROUP BY</code> to address
use cases that would otherwise need knowledge and non-trivial SQL
programming of window functions. See <a href="#xmpl:windows-by-grouping">Example 48</a>.</p>
</div>
<div class="sect3">
<h4 id="sec:eqg"><a class="anchor" href="#sec:eqg"></a><a class="link" href="#sec:eqg">11.1.1. Equivalence function used by grouping; grouping of <code>NULL</code> and <code>MISSING</code></a></h4>
<div class="paragraph">
<p>The equivalence function \$eqg\$ extends SQL&#8217;s respective function. In
particular, it behaves as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$eqg("NULL", "NULL")\$ is true, despite \$"NULL"="NULL"\$ not
being true.</p>
</li>
<li>
<p>for any two non-null values \$x\$ and \$y\$,
\$\gl{eqg}(x,y)\$ returns the same with \$x=y\$. As
is the case generally for \$=\$, while SQL&#8217;s \$=\$
will error when given incompatible types, while the PartiQL
\$=\$ will return <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Notice that PartiQL will group together the <code>NULL</code> and the <code>MISSING</code>
grouping expressions, since any grouping expression resulting to
<code>MISSING</code> has been coerced into <code>NULL</code> before <code>eqg</code> does comparisons
for grouping.  <a href="#xmpl:grouping-null-missing">Example 42</a> shows the repercussions
of coercing <code>NULL</code> into <code>MISSING</code> and also shows how to discriminate
between <code>NULL</code> and <code>MISSING</code>, if so desired.</p>
</div>
<div id="xmpl:grouping-null-missing" class="exampleblock">
<div class="title">Example 42. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query of <a href="#sec:grouping-readings">Example 38</a> will group together any log
readings where the <code>sensor</code> attribute is either <code>NULL</code> or is
altogether <code>MISSING</code>. For example, if <code>logs</code> is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>logs:[
    {&#39;sensor&#39;:  1, &#39;co&#39;:0.4},
    {&#39;sensor&#39;:  2, &#39;co&#39;:0.3},
    {&#39;sensor&#39;:  null, &#39;co&#39;:0.1},
    {&#39;sensor&#39;:  1, &#39;co&#39;:0.2},
    {&#39;co&#39;:0.5}
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>then the <code>GROUP BY</code> will output the collection of binding tuples</p>
</div>
<div class="paragraph">
<p>\$ B_"GROUP"^"out" = B_"SELECT"^"in" = \$ \$&lt; &lt;\$<br>
\$ (: "sensor":1, g: &lt; &lt; (: l:{"'sensor'":1, "'co'":0.4} :)  (: l:{"'sensor'":1, "'co'":0.2} :) &gt; &gt; :) \$<br>
\$ (: "sensor":2, g: &lt; &lt; (: l:{"'sensor'":2, "'co'":0.3} :) &gt; &gt; :) \$<br>
\$ (: "sensor":"null", g: &lt; &lt; (: l:{"'sensor'":"null", "'co'":0.1} :) (: l:{"'co'":0.5}  :) &gt; &gt; :) \$<br>
\$ &gt; &gt; \$</p>
</div>
<div class="paragraph">
<p>Notice that both the 3rd and 5th tuples <code>logs</code> of were grouped under
the \$"sensor":"null"\$ group, despite the <code>sensor</code> of the 3rd
being <code>NULL</code> while the <code>sensor</code> of the 5th being <code>MISSING</code>. The query
result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;
    {&#39;sensor&#39;:1, &#39;readings&#39;:&lt;0.4, 0.2&gt;},
    {&#39;sensor&#39;:2, &#39;readings&#39;:&lt;0.3&gt;},
    {&#39;sensor&#39;:null, &#39;readings&#39;:&lt;0.1, 0.5&gt;}
&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we wanted to discriminate the <code>NULL</code> from the <code>MISSING</code> we could
write the following query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;sensor&#39;: CASE WHEN missingFlag THEN MISSING ELSE sensor END,
              &#39;readings&#39;: (SELECT VALUE v.l.co FROM g AS v) }
FROM logs AS l
GROUP BY l.sensor IS MISSING AS missingFlag, l.sensor AS sensor GROUP AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the would output the collection of binding tuples</p>
</div>
<div class="paragraph">
<p>\$ B_"GROUP"^"out" = B_"SELECT"^"in" = \$ \$&lt; &lt;\$<br>
\$ (: "missingFlag":"false", "sensor":1, g: &lt; &lt; (: l:{"'sensor'":1, "'co'":0.4} :)  (: l:{"'sensor'":1, "'co'":0.2} :) &gt; &gt; :) \$<br>
\$ (: "missingFlag":"false", "sensor":2, g: &lt; &lt; (: l:{"'sensor'":2, "'co'":0.3} :) &gt; &gt; :) \$<br>
\$ (: "missingFlag":"false", "sensor":"null", g: &lt; &lt; (: l:{"'sensor'":"null", "'co'":0.1} :) &gt; &gt; :) \$<br>
\$ (: "missingFlag":"true", "sensor":"null", g: &lt; &lt; (: l:{"'co'":0.5}  :) &gt; &gt; :) \$<br>
\$ &gt; &gt; \$</p>
</div>
<div class="paragraph">
<p>and the query result would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;
    {&#39;sensor&#39;:1, &#39;readings&#39;:&lt;0.4, 0.2&gt;},
    {&#39;sensor&#39;:2, &#39;readings&#39;:&lt;0.3&gt;},
    {&#39;sensor&#39;:null, &#39;readings&#39;:&lt;0.1&gt;},
    {&#39;readings&#39;:&lt;0.5&gt;}
&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:group-all"><a class="anchor" href="#sec:group-all"></a><a class="link" href="#sec:group-all">11.1.2. The <code>GROUP ALL</code> variant</a></h4>
<div class="paragraph">
<p>The <code>GROUP ALL</code> variant of <code>GROUP BY</code> outputs a single binding tuple,
regardless of whether the <code>FROM</code>/<code>WHERE</code> produced any tuples, i.e.,
regardless of whether its input \$B_"GROUP"^"in"\$ is empty
or not.</p>
</div>
<div class="paragraph">
<p>The <code>GROUP ALL</code> is not increasing the expressiveness of PartiQL.
<a href="#xmpl:group-all-core">Example 43</a> shows how to achieve without <code>GROUP ALL</code>,
what the <code>GROUP ALL</code> can do. However, we include <code>GROUP ALL</code> for
facilitating the reduction of SQL&#8217;s aggregation into the core PartiQL
(see <a href="#sec:implicit-group-variable">Section 11.2.2</a>).</p>
</div>
<div id="xmpl:group-all-core" class="exampleblock">
<div class="title">Example 43. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again the <code>logs</code> data of <a href="#xmpl:nesting-readings">Example 26</a> and assume
that we want to count the total number of readings that are above
<code>1.5</code> with a core PartiQL query.  (<a href="#xmpl:group-by-nothing-sql">Example 46</a> does
the same with SQL.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;largeco&#39;:  COLL_COUNT(g)}
FROM logs AS l
WHERE l.co &gt; 1.5
GROUP ALL AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice, there are no readings above <code>1.5</code> in the example data. Since there is
no tuple that satisfies the <code>WHERE</code> clause</p>
</div>
<div class="paragraph">
<p>\$B_"WHERE"^"out" = B_"GROUP"^"in" = &lt; &lt; &gt; &gt;\$<br>
\$B_"GROUP"^"out" = B_"SELECT"^"in" = &lt; &lt; (: g: &lt; &lt; &gt; &gt;  :) &gt; &gt;\$</p>
</div>
<div class="paragraph">
<p>Since <code>COLL_COUNT(&lt;&lt;&gt;&gt;)</code> is <code>0</code>, the query result is the collection</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt; {&#39;largeco&#39;: 0} &gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Therefore the PartiQL query is equivalent to the plain SQL query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT COUNT(*) AS largeco
FROM logs AS l
WHERE l.co &gt; 1.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following core PartiQL also accomplishes the same computation,
without using <code>GROUP ALL</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{ &#39;largeco&#39;:  COLL_COUNT(SELECT VALUE l
                         FROM logs AS l
                         WHERE l.co &gt; 1.5) }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:sql-groupby"><a class="anchor" href="#sec:sql-groupby"></a><a class="link" href="#sec:sql-groupby">11.2. SQL compatibility features</a></h3>
<div class="paragraph">
<p>The group-by and aggregation of PartiQL is backwards compatible to SQL.</p>
</div>
<div class="sect3">
<h4 id="sec:grouping-attributes"><a class="anchor" href="#sec:grouping-attributes"></a><a class="link" href="#sec:grouping-attributes">11.2.1. Grouping Attributes and Direct Use of Grouping Expressions</a></h4>
<div class="paragraph">
<p>For SQL compatibility PartiQL allows <code>GROUP BY &#8230;&#8203;,e,&#8230;&#8203;</code> i.e., a
grouping expression \$e\$ that is not associated with a grouping
variable \$x\$. (In core PartiQL, one would write <code>GROUP BY &#8230;&#8203;,e
AS x,&#8230;&#8203;</code>.)</p>
</div>
<div class="paragraph">
<p>For SQL compatibility, PartiQL supports using the grouping expression
<code>e</code> in <code>HAVING</code>, <code>ORDER BY</code>, and <code>SELECT</code> clauses.</p>
</div>
<div class="paragraph">
<p>The SQL form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM ...
GROUP BY e, ...
HAVING f(e, ...)
ORDER BY f2(e, ...)
SELECT f3(e, ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>is syntactic sugar for the core PartiQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>FROM ...
GROUP BY e AS x, ...
HAVING f(x, ...)
ORDER BY f2(x, ...)
SELECT f3(x, ...)</code></pre>
</div>
</div>
<div id="xmpl:groupby-sql-vs-core" class="exampleblock">
<div class="title">Example 44. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The SQL-compatible query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT v.a+1 AS bar
FROM foo AS v
GROUP BY v.a+1</code></pre>
</div>
</div>
<div class="paragraph">
<p>is written in core PartiQL as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT VALUE {&#39;bar&#39;:  x}
FROM foo AS v
GROUP BY v.a+1 AS x GROUP AS dontcare</code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What is the &#8220;same expression&#8221;</div>
<div class="paragraph">
<p>An open question in the equivalence of the two queries in
<a href="#xmpl:groupby-sql-vs-core">Example 44</a> is the exact meaning of &#8220;same expression
\$e\$ in <code>GROUP BY</code> and <code>SELECT</code> (or <code>HAVING</code>, <code>ORDER BY</code>)&#8221;. Is
<code>v.a + 1</code> the same with <code>1 + v.a</code>?  Is <code>v.a+1</code> the same with <code>a+1</code> in
the presence of a schema that dictates that the variable <code>v</code> is a
tuple with an attribute <code>a</code>? Both SQL and PartiQL answer “no" and
“yes" respectively to the two questions. In particular:</p>
</div>
<div class="paragraph">
<p>An expression \$e\$ that appears in the <code>GROUP BY</code> clause and an
expression \$e'\$ that appears in the <code>SELECT</code> or <code>HAVING</code> or
<code>ORDER BY</code> are considered the same expression if they are
syntactically identical after performing the schema-based rewritings
of <a href="#sec:schema">Chapter 15</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sec:implicit-group-variable"><a class="anchor" href="#sec:implicit-group-variable"></a><a class="link" href="#sec:implicit-group-variable">11.2.2. SQL&#8217;s Implicit Use of the Group Variable in SQL Aggregate Functions</a></h4>
<div class="paragraph">
<p>SQL does not have explicit group variables. For SQL compatibility,
PartiQL allows the SQL aggregation functions to be fed by expressions
that do not explicitly say that there is iteration over the group
variable. Suppose that a query</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>is a <code>SELECT</code> query,</p>
</li>
<li>
<p>lacks a <code>GROUP AS</code> clause, and</p>
</li>
<li>
<p>any of the <code>SELECT</code>, <code>HAVING</code>, and/or <code>ORDER BY</code> clauses contains a
function call \$f(e)\$, where \$f\$ is a <em>SQL aggregation
function</em> such as <code>SUM</code> and <code>AVG</code>. (See <a href="#sec:SQL-aggregation-functions">Section 11.2.3</a>)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then, the query is rewritten as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the query has a <code>GROUP BY</code> clause, add to it</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>GROUP AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>g</code> is a fresh variable, i.e., a variable that is not
a database name nor a variable of the query or a variable of the queries
within which it is nested.</p>
</div>
</li>
<li>
<p>if the query has no <code>GROUP BY</code> clause, add to it</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>GROUP ALL GROUP AS g</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>g</code> is a fresh variable.</p>
</div>
</li>
<li>
<p>if the aggregation function call is <code>COUNT(*)</code>, then rewrite into
<code>COUNT(g)</code></p>
</li>
<li>
<p>otherwise, rewrite \$f(e)\$ into</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>f(SELECT VALUE e1 FROM g AS p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where \$e1\$ is produced from \$e\$ as follows: Consider the
variables \$v_1, ..., v_n\$ that appear in \$B_"GROUP"^"in"\$
(i.e., the variables defined by the query&#8217;s <code>FROM</code> and <code>LET</code> clauses)
and are not grouping attributes. Substitute each identifier \$v_i\$
(that does not stand for attribute name) in \$e\$ with
\$p.v_i\$.</p>
</div>
</li>
</ul>
</div>
<div id="xmpl:groupby-sql" class="exampleblock">
<div class="title">Example 45. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again the query of <a href="#xmpl:groupby-avg-count">Example 39</a>. It can be
written in an SQL compatible way as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT l.sensor AS sensor,
       AVG(l.co) AS avg,
       COUNT(*) AS count
FROM logs AS l
GROUP BY l.sensor</code></pre>
</div>
</div>
</div>
</div>
<div id="xmpl:group-by-nothing-sql" class="exampleblock">
<div class="title">Example 46. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query of <a href="#xmpl:group-all-core">Example 43</a> can be written in standard SQL
syntax as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT COUNT(g) AS largeco
FROM logs AS l
WHERE l.co &gt; 1.5</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that SQL does not allow nested aggregate
functions. Respectively, PartiQL does not allow one to write queries
that lack a <code>GROUP AS</code> or <code>GROUP ALL</code> clause and have nested aggregate
SQL functions.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:SQL-aggregation-functions"><a class="anchor" href="#sec:SQL-aggregation-functions"></a><a class="link" href="#sec:SQL-aggregation-functions">11.2.3. Designation of SQL aggregate functions</a></h4>
<div class="paragraph">
<p>Each implementation will have a list of SQL aggregate functions, which
are not necessarily just the ones prescribed by the standard (<code>COUNT</code>,
<code>SUM</code>, <code>AVG</code>, etc). (Recall from <a href="#sec:implicit-group-variable">Section 11.2.2</a> that
SQL aggregate functions do not use an explicit group variable.)</p>
</div>
<div class="paragraph">
<p>Furthermore, it is required that for each SQL aggregate function <code>f</code>,
if an implementation offers a corresponding core PartiQL aggregate
function, the PartiQL function is named <code>COLL_f</code>. For example, the
core PartiQL aggregate <code>COLL_AVG</code> corresponds to the SQL <code>AVG</code>
aggregate .  Nevertheless, it is possible that an implementation
offers only <code>COLL_AVG</code> or offers only <code>AVG</code>. The semantic relationship
between the SQL aggregate function and the corresponding core PartiQL
aggregate function is the one explained in
<a href="#sec:implicit-group-variable">Section 11.2.2</a>: The SQL aggregate functions do not
input explicit group variables and, thus, their semantics are
explained by the reduction to the corresponding core PartiQL
aggregate.</p>
</div>
</div>
<div class="sect3">
<h4 id="sec:select-aliases-groupby"><a class="anchor" href="#sec:select-aliases-groupby"></a><a class="link" href="#sec:select-aliases-groupby">11.2.4. Aliases from <code>SELECT</code> clause</a></h4>
<div class="paragraph">
<p>In SQL, a grouping expression may be an alias that is defined by the
<code>SELECT</code> clause. For compatibility purposes, PartiQL adopts the same
behavior.</p>
</div>
<div class="paragraph">
<p>The query, which uses the <code>SELECT</code>-defined alias feature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...,e AS a,...
FROM ...
GROUP BY ...,a,...</code></pre>
</div>
</div>
<div class="paragraph">
<p>is syntactic sugar for the query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT ...e AS a,...
FROM ...
GROUP BY ...,e,...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the grouping expression <code>a</code> is simply a shorthand for <code>e</code>.</p>
</div>
<div class="paragraph">
<p>In the case that the grouping expression is a constant positive
integer literal \$n\$, then it stands for the \$n\$th attribute
of the <code>SELECT</code> clause. However, this requires that the tuples
produced by the <code>SELECT</code> have schema and they are ordered tuples. The
relevant examples will be provided in the schema section.</p>
</div>
<div id="xmpl:select-aliases-groupby" class="exampleblock">
<div class="title">Example 47. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider the database</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>people: &lt;&lt;
    {&#39;name&#39;: &#39;zoe&#39;, &#39;age&#39;: 10, &#39;tag&#39;: &#39;child&#39;},
    {&#39;name&#39;: &#39;zoe&#39;, &#39;age&#39;: 20, &#39;tag&#39;: &#39;adult&#39;},
    {&#39;name&#39;: &#39;bill&#39;, &#39;age&#39;: 30, &#39;tag&#39;: &#39;adult&#39;}
&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT p.tag || &#39;:&#39; || p.name AS tagname, AVG(p.age) AS average
FROM people AS p
GROUP BY tagname</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to the query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT p.tag || &#39;:&#39; || p.name AS tagname, AVG(p.age) AS average
FROM people AS p
GROUP BY p.tag || &#39;:&#39; || p.name</code></pre>
</div>
</div>
<div class="paragraph">
<p>Either query results into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>people: &lt;&lt;
    {&#39;tagname&#39;: &#39;child:zoe&#39;, &#39;average&#39;: 10},
    {&#39;tagname&#39;: &#39;adult:zoe&#39;, &#39;average&#39;: 20},
    {&#39;tagname&#39;: &#39;adult:bill&#39;, &#39;average&#39;: 30}
&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:windows-by-grouping"><a class="anchor" href="#sec:windows-by-grouping"></a><a class="link" href="#sec:windows-by-grouping">11.3. Windowing cases simplified by the PartiQL grouping</a></h3>
<div id="xmpl:windows-by-grouping" class="exampleblock">
<div class="title">Example 48. &#160;</div>
<div class="content">
<div class="paragraph">
<p>Consider again a collection of sensor readings, this time with a
timestamp.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>logs:  [
    {&#39;sensor&#39;:1, &#39;co&#39;:0.4, &#39;timestamp&#39;:04:05:06},
    {&#39;sensor&#39;:1, &#39;co&#39;:0.2, &#39;timestamp&#39;:04:05:07},
    {&#39;sensor&#39;:1, &#39;co&#39;:0.5, &#39;timestamp&#39;:04:05:10},
    {&#39;sensor&#39;:2, &#39;co&#39;:0.3}
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We look for the “jump" readings that are more than 2x the previous
reading at the same sensor. The following query solves the problem
using <code>GROUP BY</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT sensor AS sensor,
      (WITH orderedReadings
               AS (SELECT v FROM oneSensorsReadings v ORDER BY v.timestamp)
       SELECT r.co, r.timestamp
       FROM orderedReadings r AT p
       WHERE r.co &gt; 2*orderedReadings[p-1].co
       ORDER BY p
      ) AS jumpReadings
FROM logs l
GROUP BY l.sensor AS sensor GROUP AS oneSensorsReadings</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>&lt;&lt;
    {&#39;sensor&#39;:1, &#39;jumpReadings&#39;:[{&#39;co&#39;:0.4, &#39;timestamp&#39;:04:05:06}]},
    {&#39;sensor&#39;:2, &#39;jumpReadings&#39;:[]}
&gt;&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section:order-by"><a class="anchor" href="#section:order-by"></a><a class="link" href="#section:order-by">12. <code>ORDER BY</code> clause</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>SQL’s <code>ORDER BY</code> orders the output data. Similarly, the PartiQL <code>ORDER
BY</code> is responsible for turning its input bag into an array. In the
following aspects, PartiQL extends the SQL semantics to resolve issues
that are not relevant in SQL but emerge when working on Ion data.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SQL’s <code>ORDER BY</code> clause orders its input using an expanded version
of the less-than function, which we call the <em>order-by less-than</em> and
denote by \$&lt;^o\$. The PartiQL \$&lt;^o\$ semantics
(<a href="#sec:order-by-less-than">Section 12.2</a>) also specify an order among values of
heterogeneous types, including complex values.</p>
</li>
<li>
<p>The interaction of <code>ORDER BY</code> with a <code>UNION</code> (or any other set
operator) of SFW queries requires attention since, unlike SQL, in
PartiQL there are no binding tuples (or any tuples at all for that
matter) after a <code>SELECT VALUE</code> clause. <a href="#sec:order-by-and-setops">Section 12.3</a>
elaborates on this aspect of PartiQL.</p>
</li>
<li>
<p>Unlike SQL, the input of an PartiQL query may also have order,
because it is an array. The user may want to preserve the order of the
input into the output. In this case, the <code>AT</code> structure in the <code>FROM</code>
clause (recall, <a href="#sec:single-item-from">Section 5.1</a>) can capture the input order
and the <code>ORDER BY</code> can recreate it. However, this order preservation
mechanism is tedious for the user. Thus, <code>ORDER BY</code> also offers an
order preservation directive.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="#sec:orderby-sql-compatibility">Section 12.4</a> and
<a href="#sec:select-variables-in-order">Section 12.5</a> discuss SQL compatibility issues.</p>
</div>
<div class="sect2">
<h3 id="sec:orderby-syntax"><a class="anchor" href="#sec:orderby-syntax"></a><a class="link" href="#sec:orderby-syntax">12.1. PartiQL Syntax</a></h3>
<div class="paragraph">
<p>Similar to SQL, the PartiQL <code>ORDER BY</code> clause syntax is:</p>
</div>
<div id="figure:orderby:bnf" class="listingblock">
<div class="title">Listing 5. EBNF Grammar for PartiQL Names</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="ebnf"><div class="lineno"><table class="linenotable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><span class="tok-k">order_by </span><span class="tok-o">=</span> <span class="tok-s2">&quot;ORDER&quot;</span><span class="tok-p">,</span> <span class="tok-s2">&quot;BY&quot;</span><span class="tok-p">,</span>
               <span class="tok-p">(</span>
                        <span class="tok-k">expr</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;ASC&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;DESC&quot;</span> <span class="tok-p">],</span> <span class="tok-p">[</span><span class="tok-s2">&quot;NULLS FIRST&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;NULLS LAST&quot;</span><span class="tok-p">],</span>
                  <span class="tok-p">{</span> <span class="tok-s2">&quot;,&quot;</span> <span class="tok-k">expr</span><span class="tok-p">,</span> <span class="tok-p">[</span> <span class="tok-s2">&quot;ASC&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;DESC&quot;</span> <span class="tok-p">],</span> <span class="tok-p">[</span><span class="tok-s2">&quot;NULLS FIRST&quot;</span><span class="tok-p">|</span><span class="tok-s2">&quot;NULLS LAST&quot;</span><span class="tok-p">],</span> <span class="tok-p">}</span>
               <span class="tok-p">)</span>
               <span class="tok-p">|</span> <span class="tok-s2">&quot;PRESERVE&quot;</span> <span class="tok-p">;</span>
</pre></div></td></tr></table></div></code></pre>
</div>
</div>
<div class="paragraph">
<p>(<a href="#figure:query:bnf">Listing 3</a>), where the sequence of <code>expr</code> is a list of
<em>ordering expressions</em>. In PartiQL a SFW query with <code>ORDER BY</code> outputs
an array, whereas a SFW query without <code>ORDER BY</code> outputs a bag.</p>
</div>
<div class="paragraph">
<p>Alike SQL’s <code>ORDER BY</code> clause, the <code>NULLS FIRST</code> and <code>NULLS LAST</code>
keywords indicate whether <code>NULL</code> and <code>MISSING</code> values are ordered
before or after all other values. Notice that in PartiQL, the <code>NULLS
FIRST</code> and <code>NULLS LAST</code> refer to both <code>NULL</code> and <code>MISSING</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:order-by-less-than"><a class="anchor" href="#sec:order-by-less-than"></a><a class="link" href="#sec:order-by-less-than">12.2. The PartiQL order-by less-than function</a></h3>
<div class="paragraph">
<p>The <code>ORDER BY</code> clause sorts its input using the <em>order-by less-than
function</em> \$&lt;^o\$, which is able to compare values of different
types (unlike SQL). In particular:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>NULL</code> and <code>MISSING</code> are always first or last and compare equally
according to \$&lt;^o\$. In other words, \$&lt;^o\$ cannot
distinguish between <code>NULL</code> and <code>MISSING</code>.</p>
</li>
<li>
<p>The boolean values are coming first among the non-absent values
(i.e., \$b &lt;^o x\$ is always true if \$b\$ is boolean and
\$x\$ is not a <code>NULL</code> or a <code>MISSING</code> or a boolean). <code>false</code> comes
before <code>true</code>.</p>
</li>
<li>
<p>The numbers come next. The comparisons between number values do not
depend on precision or specific type. Given two numbers \$x\$ and
\$y\$, the PartiQL \$x&lt;^o y\$ behaves identical to the SQL
<em>order-by less-than</em> function.  Namely, if \$x\$ and \$y\$ are
not the special values <code>-inf</code>, <code>inf</code>, or <code>nan</code>, then \$x &lt;^o y\$ is
the same with \$x &lt; y\$. The special value <code>nan</code> comes before
<code>-inf</code>, which comes before all normal numeric values, which are
followed by <code>+inf</code>.</p>
</li>
<li>
<p>Timestamp values follow and are compared by the absolute point of time
irrespective of precision or local UTC offset.</p>
</li>
<li>
<p>The text types come next ordered by their lexicographical ordering by
Unicode scalar irrespective of their specific type.</p>
</li>
<li>
<p>The LOB types follow and are ordered by their lexicographical ordering
by octet.</p>
</li>
<li>
<p>Arrays come next, and their values compare lexicographically based
on the comparison of their elements, recursively. Notice that given an
array \$ \[e_1,..., e_m ] \$ and a longer array \$ \[e_1, ...,
e_m, e_{m+1}, ..., e_n ] \$ that has the same first \$m\$ values,
the former array comes first.</p>
</li>
<li>
<p>Tuple values follow and compare lexicographically based on the sorted
attributes (as defined recursively), first by the attribute name, and
secondly by the attribute values themselves.</p>
</li>
<li>
<p>Bag values come last (except, of course, when <code>NULLS LAST</code> is
specified) and their values compare by first reducing them to arrays
by sorting their elements and then comparing the resulting arrays.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="sec:order-by-and-setops"><a class="anchor" href="#sec:order-by-and-setops"></a><a class="link" href="#sec:order-by-and-setops">12.3. Dependency of semantics on the Presence of Set Operators</a></h3>
<div class="paragraph">
<p>Coming up&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:orderby-sql-compatibility"><a class="anchor" href="#sec:orderby-sql-compatibility"></a><a class="link" href="#sec:orderby-sql-compatibility">12.4. SQL Compatibility <code>ORDER BY</code> clauses</a></h3>
<div class="paragraph">
<p>For SQL-compatibility, PartiQL allows the <code>CURRENT</code> variable to be omitted from
ordering expressions. Then when the <code>CURRENT</code> variable binds tuples, the ordering
expressions can refer directly to the attributes of those tuples.</p>
</div>
<div class="paragraph">
<p>The complete scoping rules are as follows. When all of the following
conditions are satisfied:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>an PartiQL path expression ordering expression \$as\$ appears in
the <code>ORDER BY</code> of a <code>UNION &#8230;&#8203; ORDER BY</code> query, where \$a\$ is an
identifier and \$s\$ is the potentially empty suffix of the path.</p>
</li>
<li>
<p>the expression \$as\$ is evaluated in database environment
\$p_0\$ and variables’ environment \$p\$, which defines
variables \$v_1,...,v_n\$ and none of them is named \$a\$.</p>
</li>
<li>
<p>none of the variables \$v_1,...,v_n\$ may bind to a tuple that
has an attribute \$a\$.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>then the path expression <code>as</code> resolves to <code>CURRENT.as</code>.</p>
</div>
<div class="paragraph">
<p>The most common and useful way to have the 3rd condition be satisfied
is when the <code>UNION &#8230;&#8203; ORDER BY</code> is a top-level query and, thus, the
variables environment \$p\$ is empty.</p>
</div>
</div>
<div class="sect2">
<h3 id="sec:select-variables-in-order"><a class="anchor" href="#sec:select-variables-in-order"></a><a class="link" href="#sec:select-variables-in-order">12.5. Use of <code>SELECT</code> variables in <code>ORDER BY</code> for SQL compatibility</a></h3>
<div class="paragraph">
<p>Recall from <a href="#section:environment-and-sfw">Chapter 3</a> that <code>ORDER BY</code> is
evaluated before <code>SELECT</code>. For SQL-compatibility, given <code>SELECT e AS
a</code>, PartiQL also supports the syntactic sugar of using <code>a</code> in lieu of <code>e</code> in the <code>ORDER BY</code>
clause. Therefore, both SFW queries below are equivalent:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT e AS a
FROM ...
ORDER BY a</code></pre>
</div>
</div>
<div class="paragraph">
<p>\$&lt;=&gt;\$</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT e AS a
FROM ...
ORDER BY e</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sec:literal-conversion"><a class="anchor" href="#sec:literal-conversion"></a><a class="link" href="#sec:literal-conversion">12.6. Coercion of literals for SQL compatibility</a></h3>
<div class="paragraph">
<p>Notice that definition of <code>&lt;</code> dismissed the SQL coercions. In SQL, given
explicit literals in a query, coercions may happen.</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. &#160;</div>
<div class="content">
<div class="paragraph">
<p>The query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT * FROM foo WHERE 9 &lt; &#39;10&#39;</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>SELECT * FROM foo WHERE 9 &lt; 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>because an automatic coercion of string to number will be introduced.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This aspect of SQL compatibility is introduced by rewriting. Namely,
given a query with incompatible types</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="section:setop"><a class="anchor" href="#section:setop"></a><a class="link" href="#section:setop">13. <code>UNION</code> / <code>INTERSECT</code> / <code>EXCEPT</code> clauses</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Coming up&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:pivot_clause"><a class="anchor" href="#sec:pivot_clause"></a><a class="link" href="#sec:pivot_clause">14. <code>PIVOT</code> Clause Semantics</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>PIVOT</code> clause inputs a bag of binding tuples or an array of
binding tuples.  Semantically, it is similar to <code>SELECT VALUE</code> but
whereas the latter creates a collection of values, <code>PIVOT</code> constructs
a tuple where the each input binding is evaluated to an attribute
value pair in the tuple.</p>
</div>
<div class="paragraph">
<p>The clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>PIVOT v AT a</code></pre>
</div>
</div>
<div class="paragraph">
<p>inputs a bag or an array of binding tuples and outputs a single tuple
where each evaluation of \$v\$ and \$a\$ generate an attribute
in the tuple.</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. &#160;</div>
<div class="content">
<div class="paragraph">
<p>This example illustrates a <code>PIVOT</code> that creates a tuple from a
collection of tuples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>PIVOT x.v AT x.a
FROM &lt;&lt; {&#39;a&#39;: &#39;first&#39;, &#39;v&#39;: &#39;john&#39;}, {&#39;a&#39;: &#39;last&#39;, &#39;v&#39;: &#39;doe&#39;} &gt;&gt; as x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="partiql"><span></span>{&#39;first&#39;:&#39;john&#39;, &#39;last&#39;:&#39;doe&#39;}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The expression \$a\$ is expected to evaluate into a string
value. In strict mode, it is an error if this evaluates to a
non-string value. In permissive mode, the attribute is considered
<code>MISSING</code> and does not appear in the output. The expression \$v\$
can be any PartiQL value, but if it is <code>MISSING</code> it will not be
generated in the resulting tuple.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sec:schema"><a class="anchor" href="#sec:schema"></a><a class="link" href="#sec:schema">15. Structural Types and Type-related Query Syntax and Semantics (WIP)</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The input data generally conform to a <em>structural type</em>, also often
called <em>schema</em>. The SQL semantics make extensive use of the structural
types in order to assign meaning to queries, which would not have a
meaning in the absence of such structural types.</p>
</div>
<div class="paragraph">
<p>In the interest of SQL compatibility and user convenience, PartiQL also
allows structural types to assign meaning to queries that would not have
a meaning otherwise.</p>
</div>
<div class="paragraph">
<p>We will soon specify the precise rules that provide SQL compatibility,
while keeping the schema optional and the query results stable with
respect to schema addition.</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Despite the &#8220;SQL table is a bag&#8221; and &#8220;the results of an SQL query is a table&#8221; statements of SQL textbooks, SQL also recognizes that the result of a query that has an <code>ORDER BY</code> is a list, i.e., an ordered collection of tuples.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. PartiQL also supports a syntax improvement where <code>SELECT</code> is optionally written as the last clause since, anyway, that’s the proper way to read an SQL query.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. The query author is pretty weak in chemistry and cannot enumerate the carbon oxides explicitly in their query.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. Recall, in the interest of compatibility to SQL, PartiQL allows array literals to be denoted with parentheses instead of brackets (see <a href="#sec:array-constructor">Section 6.1.2</a>).
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. A path is a <code>FROM</code>  clause path if it appears in the <code>FROM</code> clause of the SFW query in which it is <em>immediately</em> nested.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. Grouping variables is an extension of SQL by PartiQL, which interestingly simplifies dramatically the explanation of SQL semantics, as it enables the <code>GROUP BY</code> to be seen as a standalone function.
</div>
</div>
<div id="footer">
<div id="footer-text">
 v0.3.0-HEAD<br>
Last updated 2023-12-06 21:55:07 UTC
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>